<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Plankton Pac-Chomp | $COCKPANTS</title>
<style>
  /* Use same font and background styling as your index.html */
  @font-face {
    font-family: 'Krabby Patty';
    src: url('Krabby Patty.ttf') format('truetype');
    font-display: swap;
  }

  *{margin:0;padding:0;box-sizing:border-box;touch-action:manipulation}
  html,body{height:100%}
  body{
    font-family: 'Krabby Patty', Arial, sans-serif;
    min-height:100vh;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    overflow-x:hidden;
    position:relative;
    background-color: #0a3a5c;
    /* restored the exact background you used on index.html */
    background-image: url('https://i.imgur.com/q8Qd5PK.jpeg');
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
    color:#ffeb3b;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    padding:18px;
  }

  body::before{
    content:'';
    position:fixed; top:0; left:0; width:100%; height:100%;
    background: rgba(0, 20, 40, 0.5);
    z-index:0; pointer-events:none;
  }

  /* page chrome (matching index) */
  header{
    width:100%;
    max-width:980px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    z-index:5;
    margin-bottom:6px;
  }
  .title{
    display:flex;
    gap:12px;
    align-items:center;
    color:#ffeb3b;
    text-shadow: 4px 4px 0 #8B4513, 0 0 30px #ffeb3b;
    font-size:20px;
  }

  /* index-style controls */
  button, .btn {
    background: linear-gradient(135deg, rgba(139, 69, 19, 0.95), rgba(101, 67, 33, 0.95));
    border: 4px solid #ffcc00;
    color: #ffcc00;
    padding: 8px 12px;
    font-family: 'Krabby Patty', Arial, sans-serif;
    cursor: pointer;
    border-radius: 10px;
    text-decoration:none;
    display:inline-flex;
    align-items:center;
    gap:8px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  }
  .small{ font-size:14px; padding:6px 10px; }

  /* layout */
  main{
    width:100%;
    max-width:980px;
    display:flex;
    gap:14px;
    align-items:flex-start;
    z-index:5;
  }

  /* canvas container similar to previous styling */
  #canvas-wrap{
    background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.18));
    padding:12px;
    border-radius:14px;
    border: 4px solid rgba(255,235,59,0.06);
    box-shadow: 0 12px 40px rgba(0,0,0,0.6);
  }

  /* use the same visual canvas border as your old file */
  canvas{
    display:block;
    width:560px;
    height:620px;
    background:#000;
    border:8px solid #ffcc00;
    border-radius:15px;
    box-shadow:0 0 40px #ffeb3b;
    image-rendering:crisp-edges;
    image-rendering:pixelated;
  }

  /* HUD to the right, matching index colors */
  .hud{
    width:260px;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-self:flex-start;
  }
  .stat{
    background: linear-gradient(#06283b,#04222f);
    border-radius:12px;
    padding:12px;
    border: 3px solid #ffcc00;
    color:#fff;
  }
  .stat small{display:block;color:#cfe9ff;font-size:12px}

  /* back button same style and placement as before */
  .back-btn{
    background:#8B4513;
    border:4px solid #ffcc00;
    color:#ffcc00;
    padding:12px 20px;
    border-radius:12px;
    font-size:16px;
    text-decoration:none;
  }

  /* music toggle same as index */
  .music-toggle{
    position:fixed;
    bottom:20px;
    left:20px;
    width:50px;
    height:50px;
    border-radius:50%;
    background: linear-gradient(135deg, rgba(139, 69, 19, 0.9), rgba(101, 67, 33, 0.9));
    border: 3px solid #ffcc00;
    color: #ffcc00;
    font-size: 20px;
    cursor: pointer;
    z-index:1000;
    box-shadow: 0 0 15px rgba(255,200,50,0.3);
  }
  .music-toggle.muted{ opacity:0.5; border-color:#888; color:#888; }

  /* D-pad like your index's mobile layout */
  .dpad{
    position:fixed;
    right:18px;
    bottom:18px;
    width:140px;
    height:140px;
    display:grid;
    grid-template-columns: repeat(3,1fr);
    grid-template-rows: repeat(3,1fr);
    gap:8px;
    z-index:50;
    touch-action:none;
  }
  .dpad button{
    background: linear-gradient(#ffef9c,#ffd54f);
    border:none;
    border-radius:12px;
    font-size:18px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.4);
  }
  .dpad .blank{ background:transparent; box-shadow:none; pointer-events:none; }
  @media(min-width:920px){ .dpad{ display:none } }

  @media (max-width:920px){
    canvas{ width:92vw; height:92vw * 1.1071; max-height:640px } /* keep aspect */
    main{ flex-direction:column; align-items:center }
    .hud{ width:92vw; max-width:420px }
  }

  .footer-note{ font-size:12px; color:#cfe9ff; opacity:0.9; margin-top:8px; text-align:center; }
</style>
</head>
<body>
  <header>
    <div class="title">
      <a class="back-btn" href="index.html">â—€ MENU</a>
      <div style="display:flex;flex-direction:column;">
        <div style="font-size:22px;">Plankton Pac-Chomp</div>
        <div style="font-size:12px;color:#cfe9ff">â€” Bikini Bottom Arcade</div>
      </div>
    </div>

    <div style="display:flex;gap:8px;align-items:center;">
      <button id="restart" class="small">Restart</button>
      <button id="musicToggle" class="music-toggle" title="Toggle music">ðŸŽµ</button>
    </div>
  </header>

  <main>
    <div id="canvas-wrap">
      <canvas id="gameCanvas" width="560" height="620" aria-label="Plankton Pac-Chomp"></canvas>
      <div class="footer-note">Dots = bubbles â€¢ Power = Krabby Patties</div>
    </div>

    <aside class="hud" aria-hidden="false">
      <div class="stat">Score: <strong id="score">0</strong><small>Eat bubbles</small></div>
      <div class="stat">Lives: <strong id="lives">3</strong><small>Don't get eaten</small></div>
      <div class="stat">Mode: <strong id="mode">normal</strong><small>Krabby Patty = power</small></div>
      <div class="stat">Controls:<br>WASD / Arrows (desktop) â€¢ D-pad (mobile)</div>
    </aside>
  </main>

  <div class="dpad" id="dpad" aria-hidden="false">
    <div class="blank"></div>
    <button data-dir="up">â–²</button>
    <div class="blank"></div>
    <button data-dir="left">â—€</button>
    <div class="blank"></div>
    <button data-dir="right">â–¶</button>
    <div class="blank"></div>
    <button data-dir="down">â–¼</button>
  </div>

  <!-- background music (same bob.mp3 as your index) -->
  <audio id="bgMusic" loop preload="auto"><source src="bob.mp3" type="audio/mpeg"></audio>

<script>
/* Complete, fixed Plankton Pac-Chomp - game logic kept from working rebuild,
   but styling & assets restored to your index.html look.
   Important: keep Krabby Patty.ttf and bob.mp3 in the same folder.
*/

(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });

  // HUD/UI
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const modeEl = document.getElementById('mode');
  const musicToggle = document.getElementById('musicToggle');
  const restartBtn = document.getElementById('restart');
  const bgMusic = document.getElementById('bgMusic');

  // Grid config
  const TILE = 20; // smaller tile to fit the 560x620 canvas nicely
  // Map adapted to fit the canvas - uses characters:
  // '#' wall, '.' dot, 'o' power, 'P' player start, 'G' ghost lair
  const rawMap = [
    "########################",
    "#........#....#........#",
    "#.###.###.#.##.#.###.###",
    "#o###.###.#.##.#.###.###",
    "#.###.###.#.##.#.###.###",
    "#......................#",
    "#.###.#.######.#.###.###",
    "#.###.#.######.#.###.###",
    "#......#....#....#.....#",
    "######.#####.#####.#####",
    "     #.#####.#####.#    ",
    "     #.##       ##.#    ",
    "######.## ##G## ##.######",
    "      ..  #GGG#  ..     ",
    "######.## ###### ##.######",
    "     #.##       ##.#    ",
    "     #.## ###### ##.#    ",
    "######.## ###### ##.######",
    "#......................#",
    "#.###.###.#.##.#.###.###",
    "#o..#.....P..#.....#..o#",
    "########################"
  ];

  const W = Math.max(...rawMap.map(r=>r.length));
  const H = rawMap.length;
  // scale canvas to map * TILE but keep CSS size
  canvas.width = W * TILE;
  canvas.height = H * TILE;
  canvas.style.width = '560px';
  canvas.style.height = '620px';

  // build map array (mutable; pellet storage kept separate)
  const map = rawMap.map(r => (r + ' '.repeat(W)).slice(0,W).split(''));

  // game state
  let score = 0;
  let lives = 3;
  let mode = 'normal';
  let powerTimer = 0;
  let running = true;
  let totalPellets = 0;

  const pellets = new Set();
  const powers = new Set();
  let playerStart = null;
  const ghostStarts = [];

  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const c = map[y][x];
      if(c === '.') { pellets.add(`${x},${y}`); totalPellets++; }
      if(c === 'o') { powers.add(`${x},${y}`); totalPellets++; }
      if(c === 'P') playerStart = {x,y};
      if(c === 'G') ghostStarts.push({x,y});
    }
  }
  if(!playerStart) playerStart = {x: Math.floor(W/2), y: H-3};
  if(ghostStarts.length < 4){
    ghostStarts.length = 0;
    ghostStarts.push({x: Math.floor(W/2)-1, y: Math.floor(H/2)});
    ghostStarts.push({x: Math.floor(W/2)+1, y: Math.floor(H/2)});
    ghostStarts.push({x: Math.floor(W/2)-2, y: Math.floor(H/2)});
    ghostStarts.push({x: Math.floor(W/2)+2, y: Math.floor(H/2)});
  }

  // player
  const player = {
    x: playerStart.x + 0.5,
    y: playerStart.y + 0.5,
    dir: {x:0,y:0},
    nextDir: {x:0,y:0},
    speed: 6 / 60 // tiles per frame approx (6 tiles/sec)
  };

  // ghosts
  const ghostColors = ['#ff3b3b','#00f2ff','#ffb851','#8fff6b'];
  const ghosts = ghostStarts.slice(0,4).map((s,i) => ({
    x: s.x + 0.5,
    y: s.y + 0.5,
    home: {x: s.x + 0.5, y: s.y + 0.5},
    dir: {x:0,y:0},
    speed: 5.2 / 60,
    frightened: false,
    color: ghostColors[i],
    id: i,
    houseTimer: 30 + i*20
  }));

  // emoji sprites (offscreen) for better cross-device emoji rendering
  const spriteSize = TILE * 2;
  const makeEmoji = emoji => {
    const c = document.createElement('canvas');
    c.width = spriteSize; c.height = spriteSize;
    const cx = c.getContext('2d');
    cx.textAlign = 'center'; cx.textBaseline = 'middle';
    cx.font = Math.floor(spriteSize*0.9) + 'px serif';
    cx.fillText(emoji, c.width/2, c.height/2 + 2);
    return c;
  };
  const crabSprite = makeEmoji('ðŸ¦€');
  const jellySprite = makeEmoji('ðŸª¼');

  // helpers
  function isWall(x,y){
    if(x<0||y<0||x>=W||y>=H) return true;
    return map[y][x] === '#';
  }
  function isPassable(x,y){
    if(x<0||y<0||x>=W||y>=H) return false;
    return map[y][x] !== '#';
  }

  // input
  const keyMap = {
    ArrowUp:{x:0,y:-1}, w:{x:0,y:-1}, W:{x:0,y:-1},
    ArrowDown:{x:0,y:1}, s:{x:0,y:1}, S:{x:0,y:1},
    ArrowLeft:{x:-1,y:0}, a:{x:-1,y:0}, A:{x:-1,y:0},
    ArrowRight:{x:1,y:0}, d:{x:1,y:0}, D:{x:1,y:0}
  };
  window.addEventListener('keydown', e=>{
    if(keyMap[e.key]) player.nextDir = keyMap[e.key];
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
  });

  // mobile D-pad
  document.querySelectorAll('.dpad button[data-dir]').forEach(btn=>{
    const dir = btn.dataset.dir;
    const mapDir = { up:{x:0,y:-1}, down:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0} }[dir];
    btn.addEventListener('touchstart', e=>{ e.preventDefault(); player.nextDir = mapDir; }, {passive:false});
    btn.addEventListener('mousedown', e=>{ e.preventDefault(); player.nextDir = mapDir; });
  });

  // BFS for ghosts (next step)
  function bfsNext(startX,startY,targetX,targetY){
    const sx = Math.floor(startX), sy = Math.floor(startY);
    const tx = Math.floor(targetX), ty = Math.floor(targetY);
    if(sx === tx && sy === ty) return null;
    const q = [], seen = Array.from({length:H},()=>Array(W).fill(false));
    const parent = Array.from({length:H},()=>Array(W).fill(null));
    q.push({x:sx,y:sy});
    seen[sy][sx] = true;
    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    while(q.length){
      const cur = q.shift();
      if(cur.x === tx && cur.y === ty){
        let c = cur;
        while(parent[c.y][c.x] && !(parent[c.y][c.x].x === sx && parent[c.y][c.x].y === sy)){
          c = parent[c.y][c.x];
        }
        return {x: c.x - sx, y: c.y - sy};
      }
      for(const d of dirs){
        const nx = cur.x + d.x, ny = cur.y + d.y;
        if(nx<0||ny<0||nx>=W||ny>=H) continue;
        if(seen[ny][nx]) continue;
        if(!isPassable(nx,ny)) continue;
        seen[ny][nx] = true;
        parent[ny][nx] = cur;
        q.push({x:nx,y:ny});
      }
    }
    return null;
  }

  // initialize or reset pellets & state
  function resetGame(){
    pellets.clear(); powers.clear(); totalPellets = 0;
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const c = map[y][x];
        if(c === '.') { pellets.add(`${x},${y}`); totalPellets++; }
        if(c === 'o') { powers.add(`${x},${y}`); totalPellets++; }
      }
    }
    score = 0; lives = 3; powerTimer = 0; mode = 'normal'; running = true;
    // reset player
    player.x = playerStart.x + 0.5; player.y = playerStart.y + 0.5;
    player.dir = {x:0,y:0}; player.nextDir = {x:0,y:0};
    // reset ghosts
    ghosts.forEach((g,i)=>{
      g.x = ghostStarts[i].x + 0.5;
      g.y = ghostStarts[i].y + 0.5;
      g.dir = {x:0,y:0};
      g.frightened = false;
      g.houseTimer = 30 + i*20;
    });
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    modeEl.textContent = mode;
  }

  // initial pellet collection
  (function init(){
    pellets.clear(); powers.clear(); totalPellets = 0;
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const ch = map[y][x];
        if(ch === '.') { pellets.add(`${x},${y}`); totalPellets++; }
        if(ch === 'o') { powers.add(`${x},${y}`); totalPellets++; }
        if(ch === 'P') playerStart = {x,y};
      }
    }
    // ensure ghostStarts array has starting positions
    // find G positions if any
    const found = [];
    for(let y=0;y<H;y++) for(let x=0;x<W;x++) if(map[y][x] === 'G') found.push({x,y});
    if(found.length >= 4){
      for(let i=0;i<4;i++) ghostStarts[i] = found[i];
    }
    // final reset
    resetGame();
  })();

  // collision handling
  function loseLife(){
    lives--; livesEl.textContent = lives;
    if(lives <= 0){ running = false; setTimeout(()=> alert('GAME OVER\nScore: ' + score), 40); }
    else {
      // reset positions
      player.x = playerStart.x + 0.5; player.y = playerStart.y + 0.5;
      player.dir = {x:0,y:0}; player.nextDir = {x:0,y:0};
      ghosts.forEach((g,i)=>{
        g.x = ghostStarts[i].x + 0.5;
        g.y = ghostStarts[i].y + 0.5;
        g.frightened = false;
        g.dir = {x:0,y:0};
      });
    }
  }

  function checkCollisions(){
    ghosts.forEach(g=>{
      const dx = g.x - player.x;
      const dy = g.y - player.y;
      const dist2 = dx*dx + dy*dy;
      const threshold = 0.6;
      if(dist2 < threshold*threshold){
        if(g.frightened){
          score += 200;
          scoreEl.textContent = score;
          g.x = g.home.x; g.y = g.home.y;
          g.frightened = false;
        } else {
          loseLife();
        }
      }
    });
  }

  // ghost AI: BFS or random when frightened
  function ghostAI(g){
    if(g.houseTimer > 0){ g.houseTimer--; return; }
    if(g.frightened){
      const gx = Math.floor(g.x), gy = Math.floor(g.y);
      const choices = [];
      [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].forEach(d=>{
        if(isPassable(gx + d.x, gy + d.y)) choices.push(d);
      });
      if(choices.length) g.dir = choices[Math.floor(Math.random()*choices.length)];
    } else {
      const next = bfsNext(g.x, g.y, player.x, player.y);
      if(next) g.dir = next;
    }
  }

  // update loop
  const FPS = 60;
  function update(){
    if(!running) return;

    // allow reversing anytime, otherwise only turn at center
    if(player.nextDir.x === -player.dir.x && player.nextDir.y === -player.dir.y){
      player.dir = player.nextDir;
    } else {
      const cx = Math.floor(player.x) + 0.5;
      const cy = Math.floor(player.y) + 0.5;
      if(Math.abs(player.x - cx) < 0.12 && Math.abs(player.y - cy) < 0.12){
        if(isPassable(Math.floor(player.x + player.nextDir.x*0.6), Math.floor(player.y + player.nextDir.y*0.6))){
          player.dir = player.nextDir;
          player.x = cx; player.y = cy;
        }
      }
    }

    // move player
    const moveAmt = player.speed;
    const nx = player.x + player.dir.x * moveAmt;
    const ny = player.y + player.dir.y * moveAmt;
    if(isPassable(Math.floor(nx), Math.floor(ny))){
      player.x = nx; player.y = ny;
    } else {
      player.dir = {x:0,y:0};
      player.x = Math.round(player.x - 0.5) + 0.5;
      player.y = Math.round(player.y - 0.5) + 0.5;
    }

    // collect pellets/powers when near center
    const pcx = Math.floor(player.x), pcy = Math.floor(player.y);
    const key = `${pcx},${pcy}`;
    if(pellets.has(key)){
      const cx = pcx + 0.5, cy = pcy + 0.5;
      if(Math.abs(player.x - cx) < 0.45 && Math.abs(player.y - cy) < 0.45){
        pellets.delete(key); score += 10; scoreEl.textContent = score; totalPellets--;
      }
    }
    if(powers.has(key)){
      const cx = pcx + 0.5, cy = pcy + 0.5;
      if(Math.abs(player.x - cx) < 0.45 && Math.abs(player.y - cy) < 0.45){
        powers.delete(key); score += 50; scoreEl.textContent = score;
        mode = 'power'; modeEl.textContent = 'POWER!'; powerTimer = 12 * FPS;
        ghosts.forEach(g => { g.frightened = true; g.frightTimer = powerTimer; });
      }
    }

    // handle power timer
    if(mode === 'power'){
      powerTimer--;
      if(powerTimer <= 0){
        mode = 'normal'; modeEl.textContent = 'normal';
        ghosts.forEach(g => { g.frightened = false; g.frightTimer = 0; });
        powerTimer = 0;
      }
    }

    // ghosts AI sometimes to limit BFS cost
    if(Math.random() < 0.28) ghosts.forEach(g => ghostAI(g));

    // move ghosts
    ghosts.forEach(g=>{
      const speedFactor = g.frightened ? 0.85 : 1;
      const amt = g.speed * speedFactor;
      const gx = g.x + g.dir.x * amt;
      const gy = g.y + g.dir.y * amt;
      if(isPassable(Math.floor(gx), Math.floor(gy))){
        g.x = gx; g.y = gy;
      } else {
        const gxFloor = Math.floor(g.x), gyFloor = Math.floor(g.y);
        const options = [];
        [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].forEach(d=>{
          if(isPassable(gxFloor + d.x, gyFloor + d.y)) options.push(d);
        });
        if(options.length) g.dir = options[Math.floor(Math.random()*options.length)];
      }
      if(g.frightTimer) g.frightTimer--;
      if(g.frightTimer <= 0) g.frightened = false;
    });

    // collisions
    checkCollisions();

    // win
    if(totalPellets <= 0){
      running = false;
      setTimeout(()=> alert('YOU WIN! Score: ' + score), 40);
    }
  }

  // draw
  function draw(){
    // background
    ctx.fillStyle = '#021827';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw map (walls, pellets, power)
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const ch = map[y][x];
        const rx = x * TILE, ry = y * TILE;
        if(ch === '#'){
          ctx.fillStyle = '#0044aa';
          ctx.fillRect(rx, ry, TILE, TILE);
          ctx.lineWidth = 2;
          ctx.strokeStyle = '#ffeb3b';
          ctx.strokeRect(rx+1, ry+1, TILE-2, TILE-2);
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.02)';
          ctx.fillRect(rx, ry, TILE, TILE);
          const k = `${x},${y}`;
          if(pellets.has(k)){
            ctx.beginPath();
            ctx.fillStyle = '#cfe9ff';
            ctx.arc(rx + TILE/2, ry + TILE/2, Math.max(1.5, TILE*0.08), 0, Math.PI*2);
            ctx.fill();
          } else if(powers.has(k)){
            ctx.beginPath();
            ctx.fillStyle = '#ffd54f';
            ctx.arc(rx + TILE/2, ry + TILE/2, Math.max(4, TILE*0.18), 0, Math.PI*2);
            ctx.fill();
          }
        }
      }
    }

    // draw player (crab emoji)
    const px = (player.x - 0.5) * TILE;
    const py = (player.y - 0.5) * TILE;
    // glow
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,235,59,0.07)';
    ctx.ellipse(px + TILE/2, py + TILE/2, TILE*0.9, TILE*0.9, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    const s = TILE * 1.2;
    ctx.drawImage(crabSprite, 0, 0, crabSprite.width, crabSprite.height, px + (TILE - s)/2, py + (TILE - s)/2, s, s);

    // draw ghosts
    ghosts.forEach(g=>{
      const gx = (g.x - 0.5) * TILE;
      const gy = (g.y - 0.5) * TILE;
      ctx.save();
      if(g.frightened){
        ctx.fillStyle = '#8ad1ff';
        ctx.strokeStyle = '#fff';
      } else {
        ctx.fillStyle = g.color;
        ctx.strokeStyle = '#001827';
      }
      // ghost body
      const bw = TILE*0.72, bh = TILE*0.85, bx = gx + TILE*0.14, by = gy + TILE*0.05;
      roundRect(ctx, bx, by, bw, bh, TILE*0.18);
      ctx.fill();
      ctx.lineWidth = 1.2;
      ctx.stroke();
      // eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.ellipse(bx + TILE*0.2, by + TILE*0.29, TILE*0.09, TILE*0.11, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(bx + TILE*0.47, by + TILE*0.29, TILE*0.09, TILE*0.11, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#001827';
      ctx.beginPath(); ctx.ellipse(bx + TILE*0.2 + g.dir.x*0.03*TILE, by + TILE*0.29 + g.dir.y*0.03*TILE, TILE*0.035, TILE*0.045, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(bx + TILE*0.47 + g.dir.x*0.03*TILE, by + TILE*0.29 + g.dir.y*0.03*TILE, TILE*0.035, TILE*0.045, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    });

    // label
    ctx.save();
    ctx.font = '11px Krabby Patty, sans-serif';
    ctx.fillStyle = '#bfe7ff';
    ctx.fillText('Plankton Pac-Chomp', 8, canvas.height - 8);
    ctx.restore();
  }

  // util roundRect
  function roundRect(ctx,x,y,w,h,r){
    const rad = Math.min(r, Math.min(w/2, h/2));
    ctx.beginPath();
    ctx.moveTo(x+rad, y);
    ctx.arcTo(x+w, y, x+w, y+h, rad);
    ctx.arcTo(x+w, y+h, x, y+h, rad);
    ctx.arcTo(x, y+h, x, y, rad);
    ctx.arcTo(x, y, x+w, y, rad);
    ctx.closePath();
  }

  // game loop
  let last = performance.now();
  function frame(now){
    const dt = (now - last) / (1000/60);
    last = now;
    // run updates (clamping)
    const steps = Math.max(1, Math.min(3, Math.round(dt)));
    for(let i=0;i<steps;i++) update();
    draw();
    requestAnimationFrame(frame);
  }

  // music toggles (match index behavior)
  bgMusic.volume = 0.3;
  let musicOn = true;
  function tryPlayMusic(){ bgMusic.play().catch(()=>{}); }
  document.addEventListener('click', tryPlayMusic, {once:true});
  musicToggle.addEventListener('click', ()=>{
    musicOn = !musicOn;
    if(musicOn){ bgMusic.play().catch(()=>{}); musicToggle.classList.remove('muted'); musicToggle.textContent = 'ðŸŽµ'; }
    else { bgMusic.pause(); musicToggle.classList.add('muted'); musicToggle.textContent = 'ðŸ”‡'; }
  });

  // restart
  restartBtn.addEventListener('click', resetGame);

  // expose for debugging if needed
  window.PLANKTON = { resetGame, player, ghosts, map };

  // start
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
