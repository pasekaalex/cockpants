<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plankton's Formula Heist | $COCKPANTS</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="leaderboard.js"></script>
  <style>
    @font-face {
      font-family: 'Krabby Patty';
      src: url('Krabby Patty.ttf') format('truetype');
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Krabby Patty', Arial, sans-serif;
      overflow: hidden;
      background: #1a1a2e;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    
    .game-container {
      display: flex;
      gap: 20px;
      max-width: 1400px;
      width: 100%;
      padding: 20px;
      height: 100vh;
    }
    
    .left-panel {
      flex: 0 0 250px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .center-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .right-panel {
      flex: 0 0 250px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .panel {
      background: rgba(20, 20, 40, 0.95);
      border: 3px solid #00ff00;
      border-radius: 15px;
      padding: 15px;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }
    
    .panel-title {
      font-size: 18px;
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
      margin-bottom: 10px;
      text-align: center;
      border-bottom: 2px solid #00ff00;
      padding-bottom: 8px;
    }
    
    /* Game Canvas */
    .game-canvas-container {
      flex: 1;
      position: relative;
      background: #2a2a3e;
      border: 4px solid #00ff00;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.4);
    }
    
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
    }
    
    /* Stealth Meter */
    .stealth-meter {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #00ff00;
      border-radius: 10px;
      padding: 10px;
    }
    
    .stealth-label {
      font-size: 14px;
      color: #00ff00;
      margin-bottom: 8px;
      text-align: center;
    }
    
    .stealth-bar {
      width: 100%;
      height: 30px;
      background: #1a1a1a;
      border-radius: 15px;
      overflow: hidden;
      border: 2px solid #333;
      position: relative;
    }
    
    .stealth-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
      width: 0%;
      transition: width 0.2s;
      border-radius: 13px;
    }
    
    .stealth-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
    }
    
    /* Stats */
    .stat-box {
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid #00ff00;
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }
    
    .stat-label {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 5px;
    }
    
    .stat-value {
      font-size: 24px;
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
      font-weight: bold;
    }
    
    /* Objectives */
    .objective-item {
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid #555;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .objective-item.active {
      border-color: #ffff00;
      box-shadow: 0 0 10px rgba(255, 255, 0, 0.3);
    }
    
    .objective-item.complete {
      border-color: #00ff00;
      opacity: 0.7;
      text-decoration: line-through;
    }
    
    .objective-icon {
      font-size: 24px;
    }
    
    .objective-text {
      font-size: 14px;
      color: #fff;
      flex: 1;
    }
    
    /* Controls */
    .control-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 13px;
      color: #aaa;
    }
    
    .control-key {
      background: #333;
      border: 2px solid #555;
      border-radius: 5px;
      padding: 4px 8px;
      color: #00ff00;
      font-weight: bold;
      min-width: 30px;
      text-align: center;
    }
    
    /* Menu Screen */
    .menu-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0f3443 0%, #34e89e 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .menu-screen.hidden {
      display: none;
    }
    
    .menu-title {
      font-size: 64px;
      color: #00ff00;
      text-shadow: 4px 4px 0 #000, 0 0 30px #00ff00;
      margin-bottom: 20px;
      animation: titlePulse 2s ease-in-out infinite;
    }
    
    @keyframes titlePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .menu-subtitle {
      font-size: 28px;
      color: #fff;
      text-shadow: 2px 2px 0 #000;
      margin-bottom: 40px;
    }
    
    .plankton-emoji {
      font-size: 120px;
      margin-bottom: 30px;
      animation: planktonFloat 3s ease-in-out infinite;
    }
    
    @keyframes planktonFloat {
      0%, 100% { transform: translateY(0) rotate(-5deg); }
      50% { transform: translateY(-20px) rotate(5deg); }
    }
    
    .start-btn {
      background: linear-gradient(135deg, #00ff00, #00cc00);
      border: 4px solid #fff;
      color: #000;
      padding: 20px 50px;
      font-size: 36px;
      cursor: pointer;
      border-radius: 15px;
      font-family: 'Krabby Patty', Arial, sans-serif;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      transition: all 0.3s;
    }
    
    .start-btn:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0, 255, 0, 0.4);
    }
    
    .level-select {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .level-btn {
      background: rgba(0, 0, 0, 0.7);
      border: 3px solid #00ff00;
      color: #00ff00;
      padding: 15px 30px;
      font-size: 20px;
      cursor: pointer;
      border-radius: 10px;
      font-family: 'Krabby Patty', Arial, sans-serif;
      transition: all 0.3s;
    }
    
    .level-btn:hover {
      background: rgba(0, 255, 0, 0.2);
      transform: scale(1.05);
    }
    
    .level-btn.selected {
      background: #00ff00;
      color: #000;
    }
    
    /* Victory Screen */
    .victory-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }
    
    .victory-screen.show {
      display: flex;
      animation: fadeIn 0.5s;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .victory-title {
      font-size: 72px;
      color: #00ff00;
      text-shadow: 5px 5px 0 #000, 0 0 40px #00ff00;
      margin-bottom: 30px;
      animation: victoryBounce 1s ease-in-out infinite;
    }
    
    @keyframes victoryBounce {
      0%, 100% { transform: translateY(0) rotate(-3deg); }
      50% { transform: translateY(-20px) rotate(3deg); }
    }
    
    .victory-stats {
      background: rgba(0, 255, 0, 0.1);
      border: 4px solid #00ff00;
      border-radius: 20px;
      padding: 30px 50px;
      margin-bottom: 30px;
    }
    
    .victory-stat {
      font-size: 24px;
      color: #fff;
      margin: 15px 0;
      display: flex;
      justify-content: space-between;
      gap: 30px;
    }
    
    .victory-label {
      color: #aaa;
    }
    
    .victory-value {
      color: #00ff00;
      font-weight: bold;
    }
    
    .rank {
      font-size: 80px;
      color: #FFD700;
      text-shadow: 4px 4px 0 #000, 0 0 30px #FFD700;
      margin-bottom: 20px;
    }
    
    /* Caught Screen */
    .caught-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      animation: caughtShake 0.5s;
    }
    
    .caught-screen.show {
      display: flex;
    }
    
    @keyframes caughtShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-20px); }
      75% { transform: translateX(20px); }
    }
    
    .caught-title {
      font-size: 72px;
      color: #fff;
      text-shadow: 5px 5px 0 #000;
      margin-bottom: 20px;
    }
    
    .caught-subtitle {
      font-size: 32px;
      color: #ffcccc;
      margin-bottom: 40px;
    }
    
    .back-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      background: linear-gradient(135deg, rgba(139, 69, 19, 0.95), rgba(101, 67, 33, 0.95));
      border: 3px solid #ffcc00;
      color: #ffcc00;
      padding: 12px 24px;
      font-family: 'Krabby Patty', Arial, sans-serif;
      font-size: 18px;
      cursor: pointer;
      border-radius: 10px;
      text-decoration: none;
      z-index: 100;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
      transition: all 0.3s;
    }
    
    .back-btn:hover {
      transform: scale(1.05);
    }
    
    /* Alert Icon */
    .alert-icon {
      position: absolute;
      font-size: 40px;
      animation: alertPulse 0.5s ease-in-out infinite;
      pointer-events: none;
      z-index: 10;
    }
    
    @keyframes alertPulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.3); opacity: 0.7; }
    }
    
    @media (max-width: 1200px) {
      .game-container {
        flex-direction: column;
        height: auto;
        overflow-y: auto;
      }
      
      .left-panel, .right-panel {
        flex: none;
        width: 100%;
      }
      
      .game-canvas-container {
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-btn">‚óÄ MENU</a>
  
  <audio id="bgMusic" preload="auto" loop>
    <source src="bob.mp3" type="audio/mpeg">
  </audio>
  <button class="music-toggle" id="musicToggle" onclick="toggleMusic()" style="position: fixed; bottom: 20px; left: 20px; width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, rgba(0, 255, 0, 0.9), rgba(0, 200, 0, 0.9)); border: 3px solid #00ff00; color: #000; font-size: 24px; cursor: pointer; z-index: 10000; box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);">üéµ</button>
  
  <!-- Menu Screen -->
  <div class="menu-screen" id="menuScreen">
    <div class="menu-title">ü¶† PLANKTON'S FORMULA HEIST ü¶†</div>
    <div class="plankton-emoji">ü¶†</div>
    <div class="menu-subtitle">Steal the Krabby Patty Secret Formula!</div>
    <div class="level-select">
      <button class="level-btn selected" data-level="1">Level 1: Dining</button>
      <button class="level-btn" data-level="2">Level 2: Kitchen</button>
      <button class="level-btn" data-level="3">Level 3: Office</button>
    </div>
    <button class="start-btn" onclick="startGame()">START HEIST</button>
  </div>
  
  <!-- Victory Screen -->
  <div class="victory-screen" id="victoryScreen">
    <div class="victory-title">üèÜ FORMULA STOLEN! üèÜ</div>
    <div class="rank" id="rankDisplay">S</div>
    <div class="victory-stats">
      <div class="victory-stat">
        <span class="victory-label">Time:</span>
        <span class="victory-value" id="finalTime">0:00</span>
      </div>
      <div class="victory-stat">
        <span class="victory-label">Alerts:</span>
        <span class="victory-value" id="finalAlerts">0</span>
      </div>
      <div class="victory-stat">
        <span class="victory-label">Stealth Rating:</span>
        <span class="victory-value" id="finalStealth">100%</span>
      </div>
    </div>
    <button class="start-btn" onclick="nextLevel()">NEXT HEIST</button>
    <button class="start-btn" onclick="returnToMenu()" style="margin-top: 15px; font-size: 24px;">MENU</button>
  </div>
  
  <!-- Caught Screen -->
  <div class="caught-screen" id="caughtScreen">
    <div class="caught-title">üö® CAUGHT! üö®</div>
    <div class="caught-subtitle">"I'll get you next time, Krabs!"</div>
    <button class="start-btn" onclick="restartLevel()">TRY AGAIN</button>
    <button class="start-btn" onclick="returnToMenu()" style="margin-top: 15px; font-size: 24px;">MENU</button>
  </div>
  
  <!-- Game Container -->
  <div class="game-container" id="gameContainer" style="display: none;">
    <!-- Left Panel -->
    <div class="left-panel">
      <div class="panel">
        <div class="panel-title">üéØ OBJECTIVES</div>
        <div id="objectivesList"></div>
      </div>
      
      <div class="panel stealth-meter">
        <div class="stealth-label">üëÅÔ∏è DETECTION LEVEL</div>
        <div class="stealth-bar">
          <div class="stealth-fill" id="stealthFill"></div>
          <div class="stealth-icon" id="stealthIcon">üëÅÔ∏è</div>
        </div>
      </div>
    </div>
    
    <!-- Center Panel -->
    <div class="center-panel">
      <div class="game-canvas-container">
        <canvas id="gameCanvas"></canvas>
      </div>
      
      <div class="panel">
        <div class="panel-title">üéÆ CONTROLS</div>
        <div class="control-item">
          <span>Move</span>
          <span><span class="control-key">WASD</span> or <span class="control-key">‚Üë‚Üê‚Üì‚Üí</span></span>
        </div>
        <div class="control-item">
          <span>Sprint</span>
          <span><span class="control-key">SHIFT</span></span>
        </div>
        <div class="control-item">
          <span>Hide</span>
          <span><span class="control-key">SPACE</span> (near objects)</span>
        </div>
      </div>
    </div>
    
    <!-- Right Panel -->
    <div class="right-panel">
      <div class="stat-box">
        <div class="stat-label">‚è±Ô∏è TIME</div>
        <div class="stat-value" id="timeDisplay">0:00</div>
      </div>
      
      <div class="stat-box">
        <div class="stat-label">üö® ALERTS</div>
        <div class="stat-value" id="alertsDisplay">0</div>
      </div>
      
      <div class="stat-box">
        <div class="stat-label">üìç LEVEL</div>
        <div class="stat-value" id="levelDisplay">1</div>
      </div>
    </div>
  </div>
  
  <script>
    // Game State
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameRunning = false;
    let currentLevel = 1;
    let gameTime = 0;
    let alertCount = 0;
    let detectionLevel = 0;
    let maxDetection = 100;
    
    // Player
    const player = {
      x: 50,
      y: 50,
      size: 20,
      speed: 2,
      sprintSpeed: 3.5,
      color: '#00ff00',
      hiding: false,
      hasFormula: false
    };
    
    // Objectives
    let objectives = [];
    
    // Guards
    let guards = [];
    
    // Hiding spots
    let hidingSpots = [];
    
    // Walls
    let walls = [];
    
    // Formula location
    let formula = null;
    
    // Keys
    const keys = {};
    
    // Level configurations
    const levels = {
      1: {
        name: 'Dining Area',
        guards: [
          { x: 400, y: 200, speed: 1, patrolPoints: [{x: 300, y: 200}, {x: 500, y: 200}], viewDistance: 150, viewAngle: 60 },
          { x: 200, y: 400, speed: 1.2, patrolPoints: [{x: 200, y: 300}, {x: 200, y: 500}], viewDistance: 140, viewAngle: 70 }
        ],
        walls: [
          { x: 0, y: 0, width: 800, height: 20 }, // Top wall
          { x: 0, y: 580, width: 800, height: 20 }, // Bottom wall
          { x: 0, y: 0, width: 20, height: 600 }, // Left wall
          { x: 780, y: 0, width: 20, height: 600 }, // Right wall
          { x: 350, y: 250, width: 100, height: 20 }, // Center divider
          { x: 250, y: 100, width: 20, height: 100 }, // Interior wall
          { x: 530, y: 350, width: 20, height: 100 } // Interior wall
        ],
        hidingSpots: [
          { x: 100, y: 100, width: 60, height: 60, type: 'table' },
          { x: 650, y: 100, width: 60, height: 60, type: 'table' },
          { x: 100, y: 450, width: 60, height: 60, type: 'table' },
          { x: 650, y: 450, width: 60, height: 60, type: 'table' }
        ],
        formula: { x: 720, y: 80 },
        exit: { x: 50, y: 550 },
        objectives: ['Avoid SpongeBob', 'Reach the formula', 'Escape to exit']
      },
      2: {
        name: 'Kitchen',
        guards: [
          { x: 300, y: 250, speed: 1.3, patrolPoints: [{x: 200, y: 250}, {x: 400, y: 250}, {x: 400, y: 400}, {x: 200, y: 400}], viewDistance: 160, viewAngle: 65 },
          { x: 500, y: 400, speed: 1.1, patrolPoints: [{x: 500, y: 300}, {x: 600, y: 400}, {x: 500, y: 500}], viewDistance: 150, viewAngle: 60 },
          { x: 350, y: 150, speed: 0.9, patrolPoints: [{x: 250, y: 150}, {x: 450, y: 150}], viewDistance: 130, viewAngle: 80 }
        ],
        walls: [
          { x: 0, y: 0, width: 800, height: 20 }, // Top
          { x: 0, y: 580, width: 800, height: 20 }, // Bottom
          { x: 0, y: 0, width: 20, height: 600 }, // Left
          { x: 780, y: 0, width: 20, height: 600 }, // Right
          { x: 300, y: 200, width: 20, height: 150 }, // Kitchen island
          { x: 480, y: 200, width: 20, height: 150 }, // Kitchen island
          { x: 300, y: 200, width: 200, height: 20 }, // Counter top
          { x: 150, y: 450, width: 150, height: 20 }, // Kitchen counter
          { x: 550, y: 100, width: 20, height: 100 } // Wall
        ],
        hidingSpots: [
          { x: 80, y: 80, width: 70, height: 70, type: 'counter' },
          { x: 680, y: 80, width: 70, height: 70, type: 'counter' },
          { x: 80, y: 480, width: 70, height: 70, type: 'shelf' },
          { x: 680, y: 480, width: 70, height: 70, type: 'shelf' }
        ],
        formula: { x: 740, y: 60 },
        exit: { x: 50, y: 550 },
        objectives: ['Avoid Squidward & SpongeBob', 'Navigate kitchen obstacles', 'Steal the formula', 'Escape']
      },
      3: {
        name: "Mr. Krabs' Office",
        guards: [
          { x: 400, y: 300, speed: 1.5, patrolPoints: [{x: 300, y: 200}, {x: 500, y: 200}, {x: 500, y: 400}, {x: 300, y: 400}], viewDistance: 180, viewAngle: 70 },
          { x: 600, y: 150, speed: 1.3, patrolPoints: [{x: 550, y: 150}, {x: 650, y: 150}, {x: 650, y: 250}, {x: 550, y: 250}], viewDistance: 170, viewAngle: 65 },
          { x: 200, y: 450, speed: 1.2, patrolPoints: [{x: 150, y: 400}, {x: 250, y: 500}], viewDistance: 160, viewAngle: 75 },
          { x: 550, y: 450, speed: 1.4, patrolPoints: [{x: 500, y: 450}, {x: 600, y: 450}], viewDistance: 175, viewAngle: 60 }
        ],
        walls: [
          { x: 0, y: 0, width: 800, height: 20 }, // Top
          { x: 0, y: 580, width: 800, height: 20 }, // Bottom
          { x: 0, y: 0, width: 20, height: 600 }, // Left
          { x: 780, y: 0, width: 20, height: 600 }, // Right
          { x: 250, y: 150, width: 20, height: 200 }, // Office divider
          { x: 530, y: 150, width: 20, height: 200 }, // Office divider
          { x: 250, y: 330, width: 300, height: 20 }, // Desk wall
          { x: 350, y: 80, width: 100, height: 20 }, // Upper wall
          { x: 100, y: 250, width: 20, height: 100 }, // Side wall
          { x: 680, y: 350, width: 20, height: 100 } // Side wall
        ],
        hidingSpots: [
          { x: 100, y: 100, width: 65, height: 65, type: 'desk' },
          { x: 700, y: 100, width: 65, height: 65, type: 'desk' },
          { x: 100, y: 500, width: 65, height: 65, type: 'safe' },
          { x: 400, y: 520, width: 65, height: 65, type: 'box' }
        ],
        formula: { x: 740, y: 540 },
        exit: { x: 50, y: 50 },
        objectives: ['Avoid all staff + Mr. Krabs', 'Crack the safe', 'Steal the formula', 'Escape office']
      }
    };
    
    // Initialize canvas size
    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }
    
    // Load level
    function loadLevel(level) {
      currentLevel = level;
      const config = levels[level];
      
      // Reset game state
      gameTime = 0;
      alertCount = 0;
      detectionLevel = 0;
      player.x = 50;
      player.y = 50;
      player.hiding = false;
      player.hasFormula = false;
      
      // Load guards
      guards = config.guards.map(g => ({
        ...g,
        currentPoint: 0,
        angle: 0,
        alertLevel: 0
      }));
      
      // Load hiding spots
      hidingSpots = [...config.hidingSpots];
      
      // Load walls
      walls = config.walls ? [...config.walls] : [];
      
      // Load formula
      formula = { ...config.formula, collected: false };
      
      // Load exit
      exitPoint = { ...config.exit };
      
      // Load objectives
      objectives = config.objectives.map((text, i) => ({
        text,
        complete: false,
        active: i === 0
      }));
      
      updateObjectives();
      document.getElementById('levelDisplay').textContent = level;
    }
    
    // Start game
    function startGame() {
      const selectedBtn = document.querySelector('.level-btn.selected');
      const level = parseInt(selectedBtn.dataset.level);
      
      document.getElementById('menuScreen').classList.add('hidden');
      document.getElementById('gameContainer').style.display = 'flex';
      
      resizeCanvas();
      loadLevel(level);
      
      gameRunning = true;
      requestAnimationFrame(gameLoop);
    }
    
    // Level selection
    document.querySelectorAll('.level-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
      });
    });
    
    // Update objectives display
    function updateObjectives() {
      const list = document.getElementById('objectivesList');
      list.innerHTML = objectives.map(obj => `
        <div class="objective-item ${obj.active ? 'active' : ''} ${obj.complete ? 'complete' : ''}">
          <span class="objective-icon">${obj.complete ? '‚úì' : obj.active ? '‚Üí' : '‚óã'}</span>
          <span class="objective-text">${obj.text}</span>
        </div>
      `).join('');
    }
    
    // Complete objective
    function completeObjective(index) {
      if (objectives[index] && !objectives[index].complete) {
        objectives[index].complete = true;
        objectives[index].active = false;
        if (objectives[index + 1]) {
          objectives[index + 1].active = true;
        }
        updateObjectives();
      }
    }
    
    // Draw functions
    function drawPlayer() {
      ctx.save();
      
      if (player.hiding) {
        ctx.globalAlpha = 0.3;
      }
      
      // Draw Plankton emoji
      ctx.font = `${player.size * 2}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Shadow for depth
      ctx.shadowColor = 'rgba(0, 255, 0, 0.5)';
      ctx.shadowBlur = 10;
      ctx.fillText('ü¶†', player.x, player.y);
      
      ctx.restore();
    }
    
    function drawGuard(guard) {
      ctx.save();
      
      // Vision cone (behind guard)
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = guard.alertLevel > 50 ? '#ff0000' : '#ffff00';
      ctx.translate(guard.x, guard.y);
      ctx.rotate(guard.angle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, guard.viewDistance, -guard.viewAngle * Math.PI / 180, guard.viewAngle * Math.PI / 180);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      
      // Draw guard emoji
      ctx.font = '50px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Character based on alert level
      if (guard.alertLevel > 50) {
        ctx.fillText('üò°', guard.x, guard.y);
      } else {
        ctx.fillText('üßΩ', guard.x, guard.y);
      }
      
      // Alert indicator
      if (guard.alertLevel > 30) {
        ctx.fillStyle = '#ff0000';
        ctx.font = 'bold 30px Arial';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 10;
        ctx.fillText('!', guard.x + 20, guard.y - 30);
        ctx.shadowBlur = 0;
      }
      
      ctx.restore();
    }
    
    function drawHidingSpot(spot) {
      // Shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(spot.x + 5, spot.y + 5, spot.width, spot.height);
      
      // Main object
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(spot.x, spot.y, spot.width, spot.height);
      
      // Border
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 3;
      ctx.strokeRect(spot.x, spot.y, spot.width, spot.height);
      
      // Highlight on top
      ctx.fillStyle = 'rgba(139, 101, 83, 0.5)';
      ctx.fillRect(spot.x, spot.y, spot.width, 10);
      
      // Icon based on type
      ctx.font = '32px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const icons = { table: 'ü™ë', counter: 'üç≥', shelf: 'üì¶', desk: 'üóÑÔ∏è', safe: 'üîí', box: 'üì¶' };
      ctx.fillText(icons[spot.type] || 'üì¶', spot.x + spot.width/2, spot.y + spot.height/2);
      
      // Highlight if player near
      const dist = Math.hypot(player.x - (spot.x + spot.width/2), player.y - (spot.y + spot.height/2));
      if (dist < 60 && !player.hiding) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 4;
        ctx.shadowColor = '#00ff00';
        ctx.shadowBlur = 15;
        ctx.strokeRect(spot.x - 5, spot.y - 5, spot.width + 10, spot.height + 10);
        ctx.shadowBlur = 0;
        
        // "Press SPACE" text with background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(spot.x + spot.width/2 - 40, spot.y - 30, 80, 25);
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('SPACE', spot.x + spot.width/2, spot.y - 17);
      }
    }
    
    function drawWalls() {
      if (!walls || walls.length === 0) return;
      
      walls.forEach(wall => {
        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.fillRect(wall.x + 3, wall.y + 3, wall.width, wall.height);
        
        // Wall body
        ctx.fillStyle = '#4A4A4A';
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
        
        // Border
        ctx.strokeStyle = '#2A2A2A';
        ctx.lineWidth = 3;
        ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
        
        // Brick pattern
        ctx.strokeStyle = '#3A3A3A';
        ctx.lineWidth = 1;
        const brickHeight = 20;
        const brickWidth = 40;
        
        for (let y = wall.y; y < wall.y + wall.height; y += brickHeight) {
          const offset = (Math.floor((y - wall.y) / brickHeight) % 2) * (brickWidth / 2);
          for (let x = wall.x + offset; x < wall.x + wall.width; x += brickWidth) {
            ctx.strokeRect(x, y, brickWidth, brickHeight);
          }
        }
        
        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(wall.x, wall.y, wall.width, 5);
      });
    }
    
    function drawFormula() {
      if (!formula.collected) {
        // Glow effect
        ctx.save();
        ctx.shadowColor = '#FFD700';
        ctx.shadowBlur = 20;
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 40px Arial';
        ctx.fillText('üìú', formula.x - 20, formula.y + 15);
        ctx.restore();
        
        // Highlight if near
        const dist = Math.hypot(player.x - formula.x, player.y - formula.y);
        if (dist < 40) {
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(formula.x, formula.y, 35, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    }
    
    function drawExit() {
      ctx.fillStyle = player.hasFormula ? '#00ff00' : '#666';
      ctx.fillRect(exitPoint.x - 30, exitPoint.y - 30, 60, 60);
      ctx.strokeStyle = player.hasFormula ? '#00ff00' : '#333';
      ctx.lineWidth = 4;
      ctx.strokeRect(exitPoint.x - 30, exitPoint.y - 30, 60, 60);
      
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 30px Arial';
      ctx.fillText('üö™', exitPoint.x - 15, exitPoint.y + 10);
      
      // Highlight if can exit
      if (player.hasFormula) {
        const dist = Math.hypot(player.x - exitPoint.x, player.y - exitPoint.y);
        if (dist < 50) {
          ctx.strokeStyle = '#00ff00';
          ctx.lineWidth = 3;
          ctx.strokeRect(exitPoint.x - 35, exitPoint.y - 35, 70, 70);
        }
      }
    }
    
    // Update guard AI
    function updateGuard(guard) {
      const target = guard.patrolPoints[guard.currentPoint];
      const dx = target.x - guard.x;
      const dy = target.y - guard.y;
      const dist = Math.hypot(dx, dy);
      
      if (dist < 5) {
        guard.currentPoint = (guard.currentPoint + 1) % guard.patrolPoints.length;
      } else {
        guard.x += (dx / dist) * guard.speed;
        guard.y += (dy / dist) * guard.speed;
        guard.angle = Math.atan2(dy, dx);
      }
      
      // Check if player in view
      if (!player.hiding) {
        const playerDist = Math.hypot(player.x - guard.x, player.y - guard.y);
        if (playerDist < guard.viewDistance) {
          const angleToPlayer = Math.atan2(player.y - guard.y, player.x - guard.x);
          const angleDiff = Math.abs(angleToPlayer - guard.angle);
          
          if (angleDiff < guard.viewAngle * Math.PI / 180) {
            guard.alertLevel = Math.min(100, guard.alertLevel + 3);
            detectionLevel = Math.min(maxDetection, detectionLevel + 2);
          } else {
            guard.alertLevel = Math.max(0, guard.alertLevel - 1);
          }
        } else {
          guard.alertLevel = Math.max(0, guard.alertLevel - 1);
        }
      } else {
        guard.alertLevel = Math.max(0, guard.alertLevel - 2);
      }
      
      // Caught!
      if (guard.alertLevel >= 100) {
        getCaught();
      }
    }
    
    // Player movement
    function updatePlayer() {
      if (player.hiding) return;
      
      const speed = keys['Shift'] ? player.sprintSpeed : player.speed;
      
      const oldX = player.x;
      const oldY = player.y;
      
      if (keys['w'] || keys['ArrowUp']) player.y -= speed;
      if (keys['s'] || keys['ArrowDown']) player.y += speed;
      if (keys['a'] || keys['ArrowLeft']) player.x -= speed;
      if (keys['d'] || keys['ArrowRight']) player.x += speed;
      
      // Wall collision detection
      let collided = false;
      for (const wall of walls) {
        if (player.x + player.size > wall.x &&
            player.x - player.size < wall.x + wall.width &&
            player.y + player.size > wall.y &&
            player.y - player.size < wall.y + wall.height) {
          collided = true;
          break;
        }
      }
      
      if (collided) {
        player.x = oldX;
        player.y = oldY;
      }
      
      // Bounds
      player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
      
      // Sprinting increases detection slightly
      if (keys['Shift']) {
        detectionLevel = Math.min(maxDetection, detectionLevel + 0.1);
      }
      
      // Decrease detection slowly when not seen
      if (detectionLevel > 0 && guards.every(g => g.alertLevel < 30)) {
        detectionLevel = Math.max(0, detectionLevel - 0.5);
      }
      
      // Check formula collection
      if (!formula.collected) {
        const dist = Math.hypot(player.x - formula.x, player.y - formula.y);
        if (dist < 40) {
          formula.collected = true;
          player.hasFormula = true;
          completeObjective(objectives.findIndex(o => o.text.includes('formula')));
        }
      }
      
      // Check exit
      if (player.hasFormula) {
        const dist = Math.hypot(player.x - exitPoint.x, player.y - exitPoint.y);
        if (dist < 50) {
          levelComplete();
        }
      }
    }
    
    // Hide/unhide
    function toggleHide() {
      if (player.hiding) {
        player.hiding = false;
        return;
      }
      
      // Check if near hiding spot
      for (const spot of hidingSpots) {
        const spotCenterX = spot.x + spot.width / 2;
        const spotCenterY = spot.y + spot.height / 2;
        const dist = Math.hypot(player.x - spotCenterX, player.y - spotCenterY);
        if (dist < 60) {
          player.hiding = true;
          player.x = spotCenterX;
          player.y = spotCenterY;
          break;
        }
      }
    }
    
    // Game loop
    function gameLoop() {
      if (!gameRunning) return;
      
      // Clear canvas
      ctx.fillStyle = '#2a2a3e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Update
      guards.forEach(updateGuard);
      updatePlayer();
      
      // Draw (order matters for layering)
      drawWalls();
      hidingSpots.forEach(drawHidingSpot);
      drawFormula();
      drawExit();
      guards.forEach(drawGuard);
      drawPlayer();
      
      // Update UI
      gameTime += 1/60;
      const minutes = Math.floor(gameTime / 60);
      const seconds = Math.floor(gameTime % 60);
      document.getElementById('timeDisplay').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      document.getElementById('alertsDisplay').textContent = alertCount;
      
      // Update stealth meter
      const stealthPercent = (detectionLevel / maxDetection) * 100;
      document.getElementById('stealthFill').style.width = stealthPercent + '%';
      
      requestAnimationFrame(gameLoop);
    }
    
    // Caught
    function getCaught() {
      gameRunning = false;
      alertCount++;
      document.getElementById('caughtScreen').classList.add('show');
    }
    
    // Level complete
    function levelComplete() {
      gameRunning = false;
      
      // Calculate rank
      const timeScore = gameTime < 60 ? 100 : Math.max(0, 100 - (gameTime - 60));
      const alertScore = alertCount === 0 ? 100 : Math.max(0, 100 - (alertCount * 20));
      const stealthScore = 100 - detectionLevel;
      const totalScore = (timeScore + alertScore + stealthScore) / 3;
      
      let rank = 'D';
      if (totalScore >= 90) rank = 'S';
      else if (totalScore >= 80) rank = 'A';
      else if (totalScore >= 70) rank = 'B';
      else if (totalScore >= 60) rank = 'C';
      
      // Update victory screen
      const minutes = Math.floor(gameTime / 60);
      const seconds = Math.floor(gameTime % 60);
      document.getElementById('finalTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      document.getElementById('finalAlerts').textContent = alertCount;
      document.getElementById('finalStealth').textContent = Math.floor(stealthScore) + '%';
      document.getElementById('rankDisplay').textContent = rank;
      
      // Show leaderboard modal with time in seconds
      const finalTimeInSeconds = Math.floor(gameTime);
      showLeaderboardModal('plankton-heist', "Plankton's Formula Heist", finalTimeInSeconds);
      
      document.getElementById('victoryScreen').classList.add('show');
      completeObjective(objectives.length - 1);
    }
    
    // Next level
    function nextLevel() {
      document.getElementById('victoryScreen').classList.remove('show');
      if (currentLevel < 3) {
        loadLevel(currentLevel + 1);
        gameRunning = true;
        requestAnimationFrame(gameLoop);
      } else {
        returnToMenu();
      }
    }
    
    // Restart level
    function restartLevel() {
      document.getElementById('caughtScreen').classList.remove('show');
      loadLevel(currentLevel);
      gameRunning = true;
      requestAnimationFrame(gameLoop);
    }
    
    // Return to menu
    function returnToMenu() {
      document.getElementById('victoryScreen').classList.remove('show');
      document.getElementById('caughtScreen').classList.remove('show');
      document.getElementById('gameContainer').style.display = 'none';
      document.getElementById('menuScreen').classList.remove('hidden');
      gameRunning = false;
    }
    
    // Input handlers
    window.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      keys[e.key] = true;
      
      if (e.key === ' ') {
        e.preventDefault();
        toggleHide();
      }
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
      keys[e.key] = false;
    });
    
    window.addEventListener('resize', () => {
      if (gameRunning) {
        resizeCanvas();
      }
    });
    
    // Music toggle
    function toggleMusic() {
      const music = document.getElementById('bgMusic');
      const btn = document.getElementById('musicToggle');
      if (music.paused) {
        music.play();
        btn.textContent = 'üéµ';
      } else {
        music.pause();
        btn.textContent = 'üîá';
      }
    }
  </script>
</body>
</html>