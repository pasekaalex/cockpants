<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Jellyfish Fields | $COCKPANTS</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="../leaderboard.js"></script>
  <script src="../sounds.js"></script>
  <style>
    @font-face {
      font-family: 'Krabby Patty';
      src: url('../Krabby Patty.ttf') format('truetype');
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Krabby Patty', Arial, sans-serif;
      overflow: hidden;
      background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 100%);
      cursor: none;
    }
    
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: none;
    }
    
    .hud {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 30px;
      z-index: 100;
      pointer-events: none;
    }
    
    .stat-box {
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #ffcc00;
      border-radius: 10px;
      padding: 10px 20px;
      color: #ffcc00;
      font-size: 24px;
      text-shadow: 2px 2px 0 #000;
      min-width: 100px;
      text-align: center;
    }
    
    .controls {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 100;
    }
    
    .btn {
      background: linear-gradient(135deg, rgba(139, 69, 19, 0.95), rgba(101, 67, 33, 0.95));
      border: 3px solid #ffcc00;
      color: #ffcc00;
      padding: 10px 20px;
      font-family: 'Krabby Patty', Arial, sans-serif;
      font-size: 18px;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.3s;
    }
    
    .btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(255, 200, 50, 0.6);
    }
    
    .back-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
    }
    
    .menu-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(135, 206, 235, 0.95), rgba(176, 224, 230, 0.95));
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    
    .menu-screen.hidden {
      display: none;
    }
    
    .menu-screen h1 {
      font-size: 64px;
      color: #ffeb3b;
      text-shadow: 4px 4px 0 #FF69B4;
      margin-bottom: 20px;
    }
    
    .menu-screen p {
      font-size: 24px;
      color: #000;
      margin-bottom: 20px;
      text-shadow: 1px 1px 0 #fff;
    }
    
    .start-btn {
      background: linear-gradient(135deg, #FF69B4, #FF1493);
      border: 4px solid #ffcc00;
      color: #fff;
      padding: 20px 50px;
      font-size: 32px;
      cursor: pointer;
      border-radius: 15px;
      font-family: 'Krabby Patty', Arial, sans-serif;
      transition: all 0.3s;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
    }
    
    .start-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px rgba(255, 105, 180, 0.8);
    }
    
    .game-over-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    
    .game-over-screen.show {
      display: flex;
    }
    
    .game-over-screen h2 {
      font-size: 56px;
      color: #FF69B4;
      margin-bottom: 30px;
      text-shadow: 3px 3px 0 #000;
    }
    
    .game-over-screen p {
      font-size: 32px;
      color: #fff;
      margin-bottom: 20px;
    }
    
    @keyframes catchEffect {
      0% { transform: scale(0.5); opacity: 1; }
      100% { transform: scale(2); opacity: 0; }
    }
    
    .catch-effect {
      position: fixed;
      pointer-events: none;
      font-size: 48px;
      color: #FFD700;
      text-shadow: 2px 2px 0 #000;
      animation: catchEffect 0.5s ease-out;
      z-index: 1000;
    }
    
    /* Mobile styles */
    @media (max-width: 768px) {
      .hud {
        top: 10px;
        gap: 15px;
        transform: translateX(-50%) scale(0.85);
      }
      
      .stat-box {
        padding: 6px 12px;
        font-size: 14px;
      }
      
      .stat-box div:first-child {
        font-size: 11px !important;
      }
      
      .stat-box div:last-child {
        font-size: 18px;
      }
      
      .controls {
        bottom: 10px;
        right: 10px;
      }
      
      .btn {
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
      
      .menu-screen, .game-over-screen {
        padding: 30px 20px;
      }
      
      .menu-title {
        font-size: 36px;
      }
      
      .menu-subtitle {
        font-size: 16px;
      }
      
      .start-btn {
        font-size: 20px;
        padding: 15px 40px;
      }
    }
    
    @media (max-width: 480px) {
      .hud {
        gap: 8px;
        transform: translateX(-50%) scale(0.7);
        top: 5px;
      }
      
      .stat-box {
        padding: 4px 8px;
        font-size: 12px;
      }
      
      .stat-box div:last-child {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <!-- Background Music -->
  <audio id="bgMusic" loop>
    <source src="../bob.mp3" type="audio/mpeg">
  </audio>
  
  <a href="../index.html" class="btn back-btn">â—€ MENU</a>
  
  <div class="menu-screen" id="menuScreen">
    <h1>ðŸª¼ JELLYFISH FIELDS ðŸª¼</h1>
    <p>Catch jellyfish with your net!</p>
    <p style="font-size: 18px; color: #555; margin-top: -10px;">Move mouse/finger to catch â€¢ Don't let them escape!</p>
    <p style="font-size: 16px; color: #FF69B4; margin-top: 10px;">âš¡ Catch 'em all before time runs out! âš¡</p>
    <button class="start-btn" onclick="startGame()">START CATCHING</button>
  </div>
  
  <div class="game-over-screen" id="gameOverScreen">
    <h2>TIME'S UP!</h2>
    <p id="finalScore">Jellyfish Caught: 0</p>
    <p id="highScoreDisplay"></p>
    <button class="start-btn" onclick="startGame()">CATCH AGAIN</button>
  </div>
  
  <div class="hud">
    <div class="stat-box">
      <div style="font-size: 14px; color: #ccc;">CAUGHT</div>
      <div id="scoreDisplay">0</div>
    </div>
    <div class="stat-box">
      <div style="font-size: 14px; color: #ccc;">TIME</div>
      <div id="timeDisplay">60</div>
    </div>
    <div class="stat-box">
      <div style="font-size: 14px; color: #ccc;">ESCAPED</div>
      <div id="escapedDisplay">0</div>
    </div>
  </div>
  
  <div class="controls">
    <button class="btn" id="musicBtn">ðŸŽµ</button>
  </div>
  
  <canvas id="gameCanvas"></canvas>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
    
    // Game state
    let gameState = {
      jellyfish: [],
      powerUps: [],
      score: 0,
      escaped: 0,
      timeLeft: 60,
      isPlaying: false,
      highScore: 0,
      mouseX: canvas.width / 2,
      mouseY: canvas.height / 2,
      netSwing: 0,
      netActive: false
    };
    
    let lastSpawnTime = 0;
    let lastPowerUpSpawn = 0;
    let gameTimer = null;
    
    // Load high score
    const savedHighScore = localStorage.getItem('jellyfishHighScore');
    if (savedHighScore) {
      gameState.highScore = parseInt(savedHighScore);
    }
    
    // Jellyfish class
    class Jellyfish {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = canvas.height + 50;
        this.size = 40 + Math.random() * 30;
        this.speedY = -1 - Math.random() * 2;
        this.speedX = (Math.random() - 0.5) * 2;
        this.float = Math.random() * Math.PI * 2;
        this.floatSpeed = 0.05 + Math.random() * 0.05;
        this.color = ['#FF69B4', '#FFB6C1', '#FF1493', '#DB7093', '#C71585'][Math.floor(Math.random() * 5)];
        this.caught = false;
        this.opacity = 1;
      }
      
      update() {
        if (this.caught) {
          this.opacity -= 0.05;
          this.size *= 1.05;
          return this.opacity <= 0;
        }
        
        this.y += this.speedY;
        this.x += this.speedX;
        this.float += this.floatSpeed;
        
        // Drift side to side
        this.x += Math.sin(this.float) * 0.5;
        
        // Bounce off edges
        if (this.x < 0 || this.x > canvas.width) {
          this.speedX *= -1;
        }
        
        // Check if escaped (went off top)
        if (this.y < -this.size) {
          gameState.escaped++;
          updateUI();
          return true; // Remove this jellyfish
        }
        
        return false;
      }
      
      draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        
        // Jellyfish body (dome)
        const floatOffset = Math.sin(this.float) * 5;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y + floatOffset, this.size * 0.6, Math.PI, 0, true);
        ctx.fill();
        
        // Spots on dome
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(this.x - this.size * 0.2, this.y - this.size * 0.1 + floatOffset, this.size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + this.size * 0.2, this.y - this.size * 0.15 + floatOffset, this.size * 0.12, 0, Math.PI * 2);
        ctx.fill();
        
        // Tentacles
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3;
        for (let i = 0; i < 6; i++) {
          const tentacleX = this.x - this.size * 0.4 + (i * this.size * 0.16);
          const wave = Math.sin(this.float + i) * 3;
          
          ctx.beginPath();
          ctx.moveTo(tentacleX, this.y + floatOffset);
          ctx.quadraticCurveTo(
            tentacleX + wave,
            this.y + this.size * 0.4 + floatOffset,
            tentacleX + wave * 2,
            this.y + this.size * 0.8 + floatOffset
          );
          ctx.stroke();
        }
        
        ctx.restore();
      }
      
      checkCatch(netX, netY, netSize) {
        const dx = this.x - netX;
        const dy = this.y - netY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (this.size + netSize) / 2;
      }
    }
    
    // PowerUp class for time-adding jam
    class PowerUp {
      constructor() {
        this.x = Math.random() * (canvas.width - 60) + 30;
        this.y = -50;
        this.size = 40;
        this.speed = 2 + Math.random();
        this.rotation = 0;
        this.collected = false;
      }
      
      update() {
        this.y += this.speed;
        this.rotation += 0.05;
      }
      
      draw() {
        if (this.collected) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Jar body
        ctx.fillStyle = '#FFE4B5';
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(-this.size/2, -this.size/2, this.size, this.size * 0.8, 5);
        ctx.fill();
        ctx.stroke();
        
        // Jam inside
        ctx.fillStyle = '#FF1493';
        ctx.beginPath();
        ctx.roundRect(-this.size/2 + 4, -this.size/2 + 10, this.size - 8, this.size * 0.6, 3);
        ctx.fill();
        
        // Lid
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#B8860B';
        ctx.beginPath();
        ctx.roundRect(-this.size/2 - 2, -this.size/2 - 8, this.size + 4, 12, 2);
        ctx.fill();
        ctx.stroke();
        
        // Shine
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.ellipse(-this.size/4, -this.size/4, this.size/4, this.size/3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // "+10s" label
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.strokeText('+10s', 0, this.size/2 + 15);
        ctx.fillText('+10s', 0, this.size/2 + 15);
        
        ctx.restore();
      }
      
      checkCatch(netX, netY, netSize) {
        const dx = this.x - netX;
        const dy = this.y - netY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (this.size + netSize) / 2;
      }
    }
    
    // Mouse/touch controls
    canvas.addEventListener('mousemove', (e) => {
      gameState.mouseX = e.clientX;
      gameState.mouseY = e.clientY;
    });
    
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      gameState.mouseX = touch.clientX;
      gameState.mouseY = touch.clientY;
    });
    
    canvas.addEventListener('click', () => {
      if (gameState.isPlaying) {
        swingNet();
      }
    });
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameState.isPlaying) {
        const touch = e.touches[0];
        gameState.mouseX = touch.clientX;
        gameState.mouseY = touch.clientY;
        swingNet();
      }
    });
    
    function swingNet() {
      gameState.netActive = true;
      gameState.netSwing = 1;
      
      // Check for jellyfish catches
      gameState.jellyfish.forEach(jelly => {
        if (!jelly.caught && jelly.checkCatch(gameState.mouseX, gameState.mouseY, 80)) {
          jelly.caught = true;
          gameState.score++;
          
          // Play cash register sound for catching jellyfish
          soundManager.play('cash', { allowOverlap: true });
          
          updateUI();
          showCatchEffect(jelly.x, jelly.y);
        }
      });
      
      // Check for power-up catches
      gameState.powerUps.forEach(powerUp => {
        if (!powerUp.collected && powerUp.checkCatch(gameState.mouseX, gameState.mouseY, 80)) {
          powerUp.collected = true;
          gameState.timeLeft += 10; // Add 10 seconds
          
          // Play Gary meow for power-up
          soundManager.play('gary');
          
          updateUI();
          showPowerUpEffect(powerUp.x, powerUp.y);
        }
      });
      
      setTimeout(() => {
        gameState.netActive = false;
      }, 200);
    }
    
    function showPowerUpEffect(x, y) {
      const effect = document.createElement('div');
      effect.style.position = 'fixed';
      effect.style.left = x + 'px';
      effect.style.top = y + 'px';
      effect.style.color = '#FFD700';
      effect.style.fontSize = '32px';
      effect.style.fontWeight = 'bold';
      effect.style.textShadow = '2px 2px 4px #000';
      effect.style.pointerEvents = 'none';
      effect.style.zIndex = '1000';
      effect.style.animation = 'floatUp 1s ease-out';
      effect.textContent = '+10 SECONDS!';
      document.body.appendChild(effect);
      setTimeout(() => effect.remove(), 1000);
    }
    
    function showCatchEffect(x, y) {
      const effect = document.createElement('div');
      effect.className = 'catch-effect';
      effect.textContent = '+1';
      effect.style.left = x + 'px';
      effect.style.top = y + 'px';
      document.body.appendChild(effect);
      setTimeout(() => effect.remove(), 500);
    }
    
    function spawnJellyfish() {
      if (!gameState.isPlaying) return;
      
      const now = Date.now();
      // Progressive difficulty - starts at 1000ms, gets faster
      const spawnDelay = Math.max(600, 1000 - (gameState.score * 10)); // Gets faster with score
      if (now - lastSpawnTime > spawnDelay) {
        gameState.jellyfish.push(new Jellyfish());
        lastSpawnTime = now;
      }
    }
    
    function spawnPowerUp() {
      if (!gameState.isPlaying) return;
      
      const now = Date.now();
      // Spawn power-up every 15-20 seconds
      if (now - lastPowerUpSpawn > 15000 + Math.random() * 5000) {
        gameState.powerUps.push(new PowerUp());
        lastPowerUpSpawn = now;
      }
    }
    
    function drawBackground() {
      const time = Date.now() * 0.0005; // For animation
      
      // Sky gradient with more depth
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#87CEEB');
      gradient.addColorStop(0.5, '#B0E0E6');
      gradient.addColorStop(1, '#98D8C8');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Animated clouds
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      for (let i = 0; i < 5; i++) {
        const cloudX = ((time * 20 + i * 200) % (canvas.width + 200)) - 100;
        const cloudY = 50 + i * 40;
        
        // Cloud puffs
        ctx.beginPath();
        ctx.arc(cloudX, cloudY, 30, 0, Math.PI * 2);
        ctx.arc(cloudX + 25, cloudY - 10, 35, 0, Math.PI * 2);
        ctx.arc(cloudX + 50, cloudY, 30, 0, Math.PI * 2);
        ctx.arc(cloudX + 35, cloudY + 10, 25, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Flying butterflies
      ctx.save();
      for (let i = 0; i < 3; i++) {
        const butterflyX = ((time * 30 + i * 300) % (canvas.width + 100)) - 50;
        const butterflyY = 150 + Math.sin(time * 3 + i) * 50;
        const wingFlap = Math.sin(time * 10 + i) * 5;
        
        ctx.translate(butterflyX, butterflyY);
        
        // Left wing
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.ellipse(-8 + wingFlap, 0, 8, 12, -0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right wing  
        ctx.beginPath();
        ctx.ellipse(8 - wingFlap, 0, 8, 12, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Body
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.ellipse(0, 0, 3, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.translate(-butterflyX, -butterflyY);
      }
      ctx.restore();
      
      // Distant hills
      ctx.fillStyle = '#7CB342';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 150);
      for (let i = 0; i <= canvas.width; i += 50) {
        ctx.lineTo(i, canvas.height - 150 - Math.sin(i * 0.01) * 30);
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.lineTo(0, canvas.height);
      ctx.closePath();
      ctx.fill();
      
      // Grass/flowers at bottom with variety
      for (let i = 0; i < canvas.width; i += 25) {
        const height = 50 + Math.sin(i * 0.1 + time) * 15;
        const grassShade = i % 2 === 0 ? '#90EE90' : '#98FB98';
        ctx.fillStyle = grassShade;
        ctx.fillRect(i, canvas.height - height, 20, height);
      }
      
      // Colorful flowers
      const flowerColors = ['#FF69B4', '#FFD700', '#FF6347', '#9370DB'];
      for (let i = 0; i < canvas.width; i += 80) {
        const flowerX = i + 12;
        const flowerY = canvas.height - 60 - Math.sin(i * 0.1) * 10;
        const color = flowerColors[Math.floor(i / 80) % flowerColors.length];
        
        // Stem
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(flowerX, flowerY);
        ctx.lineTo(flowerX, canvas.height - 30);
        ctx.stroke();
        
        // Petals
        ctx.fillStyle = color;
        for (let p = 0; p < 5; p++) {
          const angle = (p / 5) * Math.PI * 2;
          const px = flowerX + Math.cos(angle) * 8;
          const py = flowerY + Math.sin(angle) * 8;
          ctx.beginPath();
          ctx.arc(px, py, 6, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Center
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(flowerX, flowerY, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function drawNet() {
      if (!gameState.isPlaying) return;
      
      const x = gameState.mouseX;
      const y = gameState.mouseY;
      const swingOffset = Math.sin(gameState.netSwing * Math.PI) * 15;
      
      ctx.save();
      
      // Handle
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - 20 + swingOffset, y + 30);
      ctx.stroke();
      
      // Net hoop
      ctx.strokeStyle = gameState.netActive ? '#FFD700' : '#666';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(x + swingOffset, y - 10, 40, 0, Math.PI, true);
      ctx.stroke();
      
      // Net mesh
      ctx.strokeStyle = gameState.netActive ? 'rgba(255, 215, 0, 0.6)' : 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 2;
      for (let i = -35; i <= 35; i += 10) {
        ctx.beginPath();
        ctx.moveTo(x + i + swingOffset, y - 10);
        ctx.lineTo(x + i + swingOffset, y + 30);
        ctx.stroke();
      }
      for (let i = -10; i <= 30; i += 10) {
        ctx.beginPath();
        ctx.arc(x + swingOffset, y - 10, 40 - (i + 10), Math.PI, 0, true);
        ctx.stroke();
      }
      
      if (gameState.netSwing > 0) {
        gameState.netSwing -= 0.1;
      }
      
      ctx.restore();
    }
    
    function updateUI() {
      document.getElementById('scoreDisplay').textContent = gameState.score;
      document.getElementById('timeDisplay').textContent = gameState.timeLeft;
      document.getElementById('escapedDisplay').textContent = gameState.escaped;
    }
    
    function gameLoop() {
      if (!gameState.isPlaying) return;
      
      drawBackground();
      
      // Spawn jellyfish
      spawnJellyfish();
      
      // Spawn power-ups
      spawnPowerUp();
      
      // Update and draw jellyfish
      gameState.jellyfish = gameState.jellyfish.filter(jelly => {
        const shouldRemove = jelly.update();
        if (!shouldRemove) {
          jelly.draw();
        }
        return !shouldRemove;
      });
      
      // Update and draw power-ups
      gameState.powerUps = gameState.powerUps.filter(powerUp => {
        if (powerUp.collected) return false;
        powerUp.update();
        powerUp.draw();
        // Remove if off screen
        return powerUp.y < canvas.height + 50;
      });
      
      // Draw net on top
      drawNet();
      
      requestAnimationFrame(gameLoop);
    }
    
    function startGame() {
      gameState = {
        jellyfish: [],
        powerUps: [],
        score: 0,
        escaped: 0,
        timeLeft: 60,
        isPlaying: true,
        highScore: gameState.highScore,
        mouseX: canvas.width / 2,
        mouseY: canvas.height / 2,
        netSwing: 0,
        netActive: false
      };
      
      lastSpawnTime = Date.now();
      lastPowerUpSpawn = Date.now();
      
      document.getElementById('menuScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.remove('show');
      
      // Play "I'M READY" sound
      soundManager.play('ready');
      
      updateUI();
      
      // Start music
      const music = document.getElementById('bgMusic');
      music.play().catch(err => console.log('Music autoplay blocked'));
      
      // Start timer
      gameTimer = setInterval(() => {
        gameState.timeLeft--;
        updateUI();
        
        if (gameState.timeLeft <= 0) {
          endGame();
        }
      }, 1000);
      
      gameLoop();
    }
    
    // Casino currency system
    function getCasinoBalance() {
      const balance = localStorage.getItem('casinoBalance');
      return balance ? parseFloat(balance) : 0;
    }
    
    function addCasinoDollars(amount) {
      const current = getCasinoBalance();
      const newBalance = current + amount;
      localStorage.setItem('casinoBalance', newBalance.toString());
      updateCasinoLeaderboard();
      return newBalance;
    }
    
    function calculateCasinoReward(score) {
      // Scale down rewards: 1 casino dollar per 50 points, max 50 per game
      return Math.min(Math.floor(score / 50), 50);
    }
    
    async function updateCasinoLeaderboard() {
      try {
        if (typeof submitScore === 'undefined') return;
        const balance = getCasinoBalance();
        const playerName = localStorage.getItem('casinoPlayerName') || 'Anonymous';
        if (balance > 0) {
          await submitScore('casino', playerName, Math.floor(balance * 100));
        }
      } catch (err) {
        console.error('Error updating casino leaderboard:', err);
      }
    }

    function endGame() {
      gameState.isPlaying = false;
      clearInterval(gameTimer);
      
      // Award casino dollars
      const casinoReward = calculateCasinoReward(gameState.score);
      if (casinoReward > 0) {
        addCasinoDollars(casinoReward);
        console.log(`ðŸŽ° Earned ${casinoReward} casino dollars!`);
      }
      
      document.getElementById('finalScore').textContent = `Jellyfish Caught: ${gameState.score}`;
      
      // Show leaderboard modal
      showLeaderboardModal('jellyfish-fields', 'Jellyfish Fields', gameState.score);
      
      if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem('jellyfishHighScore', gameState.score);
        document.getElementById('highScoreDisplay').textContent = 'ðŸŽ‰ NEW HIGH SCORE! ðŸŽ‰';
        document.getElementById('highScoreDisplay').style.color = '#FFD700';
      } else {
        document.getElementById('highScoreDisplay').textContent = `High Score: ${gameState.highScore}`;
        document.getElementById('highScoreDisplay').style.color = '#fff';
      }
      
      document.getElementById('gameOverScreen').classList.add('show');
    }
    
    // Music toggle
    document.getElementById('musicBtn').addEventListener('click', () => {
      const music = document.getElementById('bgMusic');
      const btn = document.getElementById('musicBtn');
      if (music.paused) {
        music.play();
        btn.textContent = 'ðŸŽµ';
      } else {
        music.pause();
        btn.textContent = 'ðŸ”‡';
      }
    });
    
    // Initial draw
    drawBackground();
  </script>
</body>
</html>