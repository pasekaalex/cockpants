<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boating School Chaos | $COCKPANTS</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="../leaderboard.js"></script>
  <script src="../sounds.js"></script>
  <style>
    @font-face {
      font-family: 'Krabby Patty';
      src: url('../Krabby Patty.ttf') format('truetype');
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Krabby Patty', Arial, sans-serif;
      overflow: hidden;
      background: linear-gradient(180deg, #87CEEB 0%, #4682B4 100%);
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    
    /* HUD */
    .hud {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 100;
      pointer-events: none;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 90vw;
    }
    
    .stat-box {
      background: rgba(0, 0, 0, 0.85);
      border: 3px solid #FFD700;
      border-radius: 12px;
      padding: 10px 20px;
      color: #FFD700;
      font-size: 22px;
      text-shadow: 2px 2px 4px #000;
      min-width: 100px;
      text-align: center;
      backdrop-filter: blur(5px);
    }

    .stat-label {
      font-size: 14px;
      opacity: 0.8;
      display: block;
    }

    .stat-value {
      font-size: 28px;
      font-weight: bold;
      display: block;
    }
    
    /* Controls */
    .controls {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 100;
      flex-wrap: wrap;
      justify-content: flex-end;
      max-width: 300px;
    }
    
    .btn {
      background: linear-gradient(135deg, rgba(139, 69, 19, 0.95), rgba(101, 67, 33, 0.95));
      border: 3px solid #FFD700;
      color: #FFD700;
      padding: 10px 20px;
      font-family: 'Krabby Patty', Arial, sans-serif;
      font-size: 16px;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.3s;
      backdrop-filter: blur(5px);
    }
    
    .btn:hover {
      transform: scale(1.08);
      box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
    }

    .btn:active {
      transform: scale(0.95);
    }
    
    .back-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
    }

    /* Combo Display */
    .combo-display {
      position: fixed;
      top: 120px;
      right: 20px;
      background: rgba(255, 140, 0, 0.9);
      border: 4px solid #FFD700;
      border-radius: 15px;
      padding: 15px 25px;
      color: #FFF;
      font-size: 32px;
      text-shadow: 3px 3px 6px #000;
      z-index: 100;
      animation: comboPulse 0.5s infinite;
      display: none;
    }

    @keyframes comboPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .combo-display.active {
      display: block;
    }

    /* Power-up Display */
    .powerup-display {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 100;
    }

    .powerup-item {
      background: rgba(0, 0, 0, 0.85);
      border: 3px solid #00FF00;
      border-radius: 12px;
      padding: 10px 20px;
      color: #00FF00;
      font-size: 24px;
      text-shadow: 2px 2px 4px #000;
      backdrop-filter: blur(5px);
      animation: powerupGlow 1s infinite;
    }

    @keyframes powerupGlow {
      0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 0, 0.5); }
      50% { box-shadow: 0 0 25px rgba(0, 255, 0, 0.9); }
    }

    .powerup-item.inactive {
      opacity: 0.3;
      border-color: #666;
      color: #666;
      animation: none;
    }
    
    /* Menu Screen - ENTRANCE IMAGE */
    .menu-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4)),
                  url('https://i.imgur.com/VLydvTc.png');
      background-size: cover;
      background-position: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    
    .menu-screen.hidden {
      display: none;
    }
    
    .game-title {
      font-size: 72px;
      color: #FFD700;
      text-shadow: 5px 5px 10px rgba(0,0,0,0.8);
      margin-bottom: 20px;
      animation: titleFloat 3s infinite;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px 40px;
      border-radius: 20px;
      border: 4px solid #FFD700;
    }

    @keyframes titleFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }
    
    .menu-subtitle {
      font-size: 28px;
      color: #FFF;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
      margin-bottom: 40px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 30px;
      border-radius: 15px;
    }
    
    .start-btn {
      background: linear-gradient(135deg, #FFD700, #FFA500);
      border: 5px solid #FF8C00;
      color: #8B4513;
      padding: 20px 60px;
      font-family: 'Krabby Patty', Arial, sans-serif;
      font-size: 36px;
      cursor: pointer;
      border-radius: 20px;
      transition: all 0.3s;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(255,255,255,0.5);
    }
    
    .start-btn:hover {
      transform: scale(1.12);
      box-shadow: 0 15px 40px rgba(255,165,0,0.8);
    }

    .start-btn:active {
      transform: scale(1.05);
    }
    
    /* Game Over Screen */
    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 300;
    }
    
    .game-over.active {
      display: flex;
    }
    
    .game-over-title {
      font-size: 64px;
      color: #FF4444;
      text-shadow: 4px 4px 8px #000;
      margin-bottom: 30px;
      animation: gameOverShake 0.5s;
    }

    @keyframes gameOverShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-20px); }
      75% { transform: translateX(20px); }
    }
    
    .final-stats {
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid #FFD700;
      border-radius: 15px;
      padding: 30px;
      margin-bottom: 30px;
    }
    
    .final-stat {
      font-size: 28px;
      color: #FFD700;
      margin: 10px 0;
      text-shadow: 2px 2px 4px #000;
    }

    /* Score Popup */
    .score-popup {
      position: fixed;
      font-size: 36px;
      color: #FFD700;
      text-shadow: 3px 3px 6px #000;
      font-weight: bold;
      animation: scoreFloat 1.5s ease-out forwards;
      pointer-events: none;
      z-index: 150;
    }

    @keyframes scoreFloat {
      0% {
        opacity: 1;
        transform: translateY(0) scale(0.5);
      }
      20% {
        transform: translateY(-20px) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translateY(-80px) scale(1);
      }
    }

    /* Milestone Banner */
    .milestone-banner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 215, 0, 0.95);
      border: 6px solid #FF8C00;
      border-radius: 20px;
      padding: 30px 60px;
      font-size: 48px;
      color: #8B4513;
      text-shadow: 3px 3px 6px rgba(255,255,255,0.5);
      z-index: 250;
      animation: milestoneBounce 0.8s;
      display: none;
      font-weight: bold;
    }

    @keyframes milestoneBounce {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }

    .milestone-banner.active {
      display: block;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .game-title {
        font-size: 42px;
        padding: 15px 25px;
      }

      .menu-subtitle {
        font-size: 20px;
        padding: 10px 20px;
      }

      .start-btn {
        font-size: 28px;
        padding: 15px 40px;
      }

      .stat-box {
        font-size: 16px;
        padding: 8px 12px;
        min-width: 80px;
      }

      .stat-value {
        font-size: 22px;
      }

      .combo-display {
        font-size: 24px;
        padding: 10px 15px;
      }

      .powerup-item {
        font-size: 18px;
        padding: 8px 15px;
      }
    }
  </style>
</head>
<body>
  <!-- Menu Screen with Mrs. Puff's Boating School -->
  <div class="menu-screen" id="menuScreen">
    <h1 class="game-title">‚õµ BOATING SCHOOL CHAOS ‚õµ</h1>
    <p class="menu-subtitle">Pass Mrs. Puff's Driving Test!</p>
    <button class="start-btn" onclick="startGame()">START TEST!</button>
  </div>

  <!-- Game Over Screen -->
  <div class="game-over" id="gameOver">
    <h1 class="game-over-title">FAILED! üí•</h1>
    <div class="final-stats">
      <div class="final-stat">Distance: <span id="finalDistance">0</span>m</div>
      <div class="final-stat">Score: <span id="finalScore">0</span></div>
      <div class="final-stat">Stars: <span id="finalStars">0</span> ‚≠ê</div>
      <div class="final-stat">Max Combo: <span id="finalCombo">0</span>x</div>
    </div>
    <button class="btn" onclick="restartGame()">TRY AGAIN</button>
    <button class="btn" onclick="backToMenu()">MAIN MENU</button>
  </div>

  <!-- Canvas -->
  <canvas id="canvas"></canvas>

  <!-- HUD -->
  <div class="hud">
    <div class="stat-box">
      <span class="stat-label">SCORE</span>
      <span class="stat-value" id="score">0</span>
    </div>
    <div class="stat-box">
      <span class="stat-label">DISTANCE</span>
      <span class="stat-value" id="distance">0m</span>
    </div>
    <div class="stat-box">
      <span class="stat-label">LIVES</span>
      <span class="stat-value" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
    </div>
    <div class="stat-box">
      <span class="stat-label">STARS</span>
      <span class="stat-value" id="starsCollected">0 ‚≠ê</span>
    </div>
  </div>

  <!-- Combo Display -->
  <div class="combo-display" id="comboDisplay">
    COMBO: <span id="comboValue">0</span>x
  </div>

  <!-- Power-ups Display -->
  <div class="powerup-display">
    <div class="powerup-item inactive" id="shieldDisplay">üõ°Ô∏è SHIELD</div>
    <div class="powerup-item inactive" id="speedDisplay">‚ö° BOOST</div>
    <div class="powerup-item inactive" id="magnetDisplay">üß≤ MAGNET</div>
  </div>

  <!-- Milestone Banner -->
  <div class="milestone-banner" id="milestoneBanner"></div>

  <!-- Back Button -->
  <button class="btn back-btn" onclick="window.location.href='../index.html'">‚Üê BACK</button>

  <script>
    // Game State
    let gameState = {
      playing: false,
      score: 0,
      distance: 0,
      lives: 3,
      stars: 0,
      combo: 0,
      maxCombo: 0,
      speed: 0.15,
      baseSpeed: 0.15,
      
      // Power-ups
      shield: { active: false, duration: 0 },
      speedBoost: { active: false, duration: 0 },
      magnet: { active: false, duration: 0 },
      
      // Milestones
      milestones: {
        distance100: false,
        distance500: false,
        distance1000: false,
        perfectRun: false,
        combo10: false
      },
      
      perfectRunTimer: 0,
      lastHitTime: 0
    };

    // THREE.js Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x87CEEB);

    camera.position.set(0, 3, 5);
    camera.lookAt(0, 0, 0);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 5);
    scene.add(directionalLight);

    // Player Boat - Better looking boat shape
    const boatGroup = new THREE.Group();
    
    // Main hull (rounded box)
    const hullGeometry = new THREE.BoxGeometry(0.8, 0.4, 1.2);
    const hullMaterial = new THREE.MeshPhongMaterial({ color: 0xFF6B6B });
    const hull = new THREE.Mesh(hullGeometry, hullMaterial);
    hull.position.y = 0;
    boatGroup.add(hull);
    
    // Front point (cone for bow)
    const bowGeometry = new THREE.ConeGeometry(0.4, 0.6, 8);
    const bowMaterial = new THREE.MeshPhongMaterial({ color: 0xFF6B6B });
    const bow = new THREE.Mesh(bowGeometry, bowMaterial);
    bow.rotation.z = -Math.PI / 2;
    bow.position.z = -0.9;
    boatGroup.add(bow);
    
    // Small cabin/mast
    const cabinGeometry = new THREE.BoxGeometry(0.3, 0.6, 0.4);
    const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
    const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
    cabin.position.y = 0.5;
    cabin.position.z = 0.2;
    boatGroup.add(cabin);
    
    const boat = boatGroup;
    boat.position.y = 0.5;
    scene.add(boat);

    // Road/Ocean
    const roadGeometry = new THREE.PlaneGeometry(10, 100);
    const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x4682B4 });
    const road = new THREE.Mesh(roadGeometry, roadMaterial);
    road.rotation.x = -Math.PI / 2;
    road.position.z = -45;
    scene.add(road);

    // Lane markers
    const laneMarkers = [];
    for (let i = 0; i < 20; i++) {
      const markerGeometry = new THREE.BoxGeometry(0.2, 0.1, 2);
      const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      marker.position.set(-2.5, 0.05, -i * 5);
      scene.add(marker);
      laneMarkers.push(marker);
      
      const marker2 = marker.clone();
      marker2.position.x = 2.5;
      scene.add(marker2);
      laneMarkers.push(marker2);
    }

    // Game Objects
    const obstacles = [];
    const collectibles = [];
    const powerups = [];
    const particles = [];

    // Obstacle Types
    const obstacleTypes = [
      { color: 0x8B4513, size: 0.8, points: -50, name: 'rock' },
      { color: 0xFF0000, size: 0.7, points: -75, name: 'barrel' },
      { color: 0x00FF00, size: 0.6, points: -60, name: 'buoy' },
      { color: 0x0000FF, size: 1.0, points: -100, name: 'boat' },
      { color: 0x000000, size: 0.9, points: -150, name: 'mine' }
    ];

    // Input Handling
    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.key] = true);
    window.addEventListener('keyup', (e) => keys[e.key] = false);

    // Touch controls for mobile
    let touchStartX = 0;
    window.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
    });
    window.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touchX = e.touches[0].clientX;
      const diff = touchX - touchStartX;
      
      if (diff > 20) {
        keys['ArrowRight'] = true;
        keys['ArrowLeft'] = false;
      } else if (diff < -20) {
        keys['ArrowLeft'] = true;
        keys['ArrowRight'] = false;
      }
      
      touchStartX = touchX;
    });
    window.addEventListener('touchend', () => {
      keys['ArrowLeft'] = false;
      keys['ArrowRight'] = false;
    });

    // Spawn Obstacle
    function spawnObstacle() {
      if (!gameState.playing) return;
      
      const difficultyLevel = Math.floor(gameState.distance / 100);
      const availableTypes = obstacleTypes.slice(0, Math.min(difficultyLevel + 1, obstacleTypes.length));
      
      const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
      
      const geometry = type.name === 'boat' 
        ? new THREE.BoxGeometry(1.2, 0.8, type.size)
        : new THREE.SphereGeometry(type.size, 8, 8);
      
      const material = new THREE.MeshPhongMaterial({ color: type.color });
      const obstacle = new THREE.Mesh(geometry, material);
      
      const lanes = [-3, 0, 3];
      obstacle.position.set(
        lanes[Math.floor(Math.random() * lanes.length)],
        type.size,
        -50
      );
      
      obstacle.userData = { type: type, hit: false };
      scene.add(obstacle);
      obstacles.push(obstacle);
    }

    // Spawn Star (Collectible)
    function spawnStar() {
      if (!gameState.playing) return;
      
      const starGeometry = new THREE.OctahedronGeometry(0.4, 0);
      const starMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xFFD700,
        emissive: 0xFFD700,
        emissiveIntensity: 0.5
      });
      const star = new THREE.Mesh(starGeometry, starMaterial);
      
      const lanes = [-3, 0, 3];
      star.position.set(
        lanes[Math.floor(Math.random() * lanes.length)],
        1,
        -50
      );
      
      star.userData = { collected: false, points: 100 };
      scene.add(star);
      collectibles.push(star);
    }

    // Spawn Power-up
    function spawnPowerup() {
      if (!gameState.playing) return;
      
      const types = [
        { color: 0x00FFFF, type: 'shield' },
        { color: 0xFFFF00, type: 'speed' },
        { color: 0xFF00FF, type: 'magnet' }
      ];
      
      const powerupType = types[Math.floor(Math.random() * types.length)];
      
      const geometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
      const material = new THREE.MeshPhongMaterial({ 
        color: powerupType.color,
        emissive: powerupType.color,
        emissiveIntensity: 0.3
      });
      const powerup = new THREE.Mesh(geometry, material);
      
      const lanes = [-3, 0, 3];
      powerup.position.set(
        lanes[Math.floor(Math.random() * lanes.length)],
        1,
        -50
      );
      
      powerup.userData = { type: powerupType.type, collected: false };
      scene.add(powerup);
      powerups.push(powerup);
    }

    // Create Particle Effect
    function createParticles(position, color, count = 15) {
      for (let i = 0; i < count; i++) {
        const geometry = new THREE.SphereGeometry(0.1, 4, 4);
        const material = new THREE.MeshBasicMaterial({ color: color });
        const particle = new THREE.Mesh(geometry, material);
        
        particle.position.copy(position);
        particle.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.3,
          Math.random() * 0.3,
          (Math.random() - 0.5) * 0.3
        );
        particle.life = 1.0;
        
        scene.add(particle);
        particles.push(particle);
      }
    }

    // Show Score Popup
    function showScorePopup(points) {
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.textContent = `+${points}`;
      popup.style.left = (window.innerWidth / 2 + (Math.random() - 0.5) * 100) + 'px';
      popup.style.top = (window.innerHeight / 3) + 'px';
      document.body.appendChild(popup);
      
      setTimeout(() => popup.remove(), 1500);
    }

    // Show Milestone
    function showMilestone(text) {
      const banner = document.getElementById('milestoneBanner');
      banner.textContent = text;
      banner.classList.add('active');
      
      soundManager.play('victory');
      
      setTimeout(() => {
        banner.classList.remove('active');
      }, 2000);
    }

    // Check Milestones
    function checkMilestones() {
      if (gameState.distance >= 100 && !gameState.milestones.distance100) {
        gameState.milestones.distance100 = true;
        showMilestone('üéâ 100 METERS! üéâ');
        gameState.score += 500;
      }
      
      if (gameState.distance >= 500 && !gameState.milestones.distance500) {
        gameState.milestones.distance500 = true;
        showMilestone('üèÜ 500 METERS! üèÜ');
        gameState.score += 1000;
      }
      
      if (gameState.distance >= 1000 && !gameState.milestones.distance1000) {
        gameState.milestones.distance1000 = true;
        showMilestone('üåü 1 KILOMETER! üåü');
        gameState.score += 2000;
      }
      
      if (gameState.combo >= 10 && !gameState.milestones.combo10) {
        gameState.milestones.combo10 = true;
        showMilestone('üî• COMBO x10! üî•');
        gameState.score += 500;
      }
      
      if (Date.now() - gameState.lastHitTime > 30000 && !gameState.milestones.perfectRun) {
        gameState.milestones.perfectRun = true;
        showMilestone('‚ú® PERFECT RUN! ‚ú®');
        gameState.score += 1500;
        soundManager.play('ohyeah');
      }
    }

    // Update Power-ups
    function updatePowerups(delta) {
      if (gameState.shield.active) {
        gameState.shield.duration -= delta;
        if (gameState.shield.duration <= 0) {
          gameState.shield.active = false;
          document.getElementById('shieldDisplay').classList.add('inactive');
        }
        // Shield visual effect on all boat parts
        boat.children.forEach(part => {
          if (part.material) {
            part.material.emissive.setHex(0x00FFFF);
            part.material.emissiveIntensity = 0.5;
          }
        });
      }
      
      if (gameState.speedBoost.active) {
        gameState.speedBoost.duration -= delta;
        if (gameState.speedBoost.duration <= 0) {
          gameState.speedBoost.active = false;
          gameState.speed = gameState.baseSpeed;
          document.getElementById('speedDisplay').classList.add('inactive');
        }
      }
      
      if (gameState.magnet.active) {
        gameState.magnet.duration -= delta;
        if (gameState.magnet.duration <= 0) {
          gameState.magnet.active = false;
          document.getElementById('magnetDisplay').classList.add('inactive');
        }
        
        collectibles.forEach(star => {
          if (!star.userData.collected) {
            const distance = boat.position.distanceTo(star.position);
            if (distance < 5) {
              const direction = boat.position.clone().sub(star.position).normalize();
              star.position.add(direction.multiplyScalar(0.2));
            }
          }
        });
      }
      
      if (!gameState.shield.active) {
        boat.children.forEach(part => {
          if (part.material) {
            part.material.emissive.setHex(0x000000);
            part.material.emissiveIntensity = 0;
          }
        });
      }
    }

    // Collision Detection
    function checkCollisions() {
      const boatBox = new THREE.Box3().setFromObject(boat);
      
      obstacles.forEach(obstacle => {
        if (!obstacle.userData.hit) {
          const obstacleBox = new THREE.Box3().setFromObject(obstacle);
          
          if (boatBox.intersectsBox(obstacleBox)) {
            obstacle.userData.hit = true;
            
            if (gameState.shield.active) {
              createParticles(obstacle.position, 0x00FFFF, 20);
              soundManager.play('dolphin');
            } else {
              gameState.lives--;
              gameState.combo = 0;
              gameState.lastHitTime = Date.now();
              gameState.milestones.perfectRun = false;
              
              updateLivesDisplay();
              createParticles(boat.position, 0xFF0000, 25);
              shakeScreen();
              soundManager.play('puffscream');
              
              if (gameState.lives <= 0) {
                endGame();
              }
            }
            
            gameState.score += obstacle.userData.type.points;
            scene.remove(obstacle);
          }
        }
      });
      
      collectibles.forEach(star => {
        if (!star.userData.collected) {
          const starBox = new THREE.Box3().setFromObject(star);
          
          if (boatBox.intersectsBox(starBox)) {
            star.userData.collected = true;
            gameState.stars++;
            gameState.combo++;
            gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
            
            const comboBonus = gameState.combo * 10;
            const totalPoints = star.userData.points + comboBonus;
            
            gameState.score += totalPoints;
            
            createParticles(star.position, 0xFFD700, 12);
            showScorePopup(totalPoints);
            soundManager.play('cash');
            
            scene.remove(star);
            
            if (gameState.combo >= 3) {
              document.getElementById('comboDisplay').classList.add('active');
              document.getElementById('comboValue').textContent = gameState.combo;
            } else {
              document.getElementById('comboDisplay').classList.remove('active');
            }
          }
        }
      });
      
      powerups.forEach(powerup => {
        if (!powerup.userData.collected) {
          const powerupBox = new THREE.Box3().setFromObject(powerup);
          
          if (boatBox.intersectsBox(powerupBox)) {
            powerup.userData.collected = true;
            
            createParticles(powerup.position, powerup.material.color.getHex(), 15);
            soundManager.play('ready');
            
            const type = powerup.userData.type;
            if (type === 'shield') {
              gameState.shield.active = true;
              gameState.shield.duration = 5;
              document.getElementById('shieldDisplay').classList.remove('inactive');
            } else if (type === 'speed') {
              gameState.speedBoost.active = true;
              gameState.speedBoost.duration = 5;
              gameState.speed = gameState.baseSpeed * 1.5;
              document.getElementById('speedDisplay').classList.remove('inactive');
            } else if (type === 'magnet') {
              gameState.magnet.active = true;
              gameState.magnet.duration = 8;
              document.getElementById('magnetDisplay').classList.remove('inactive');
            }
            
            scene.remove(powerup);
          }
        }
      });
    }

    // Screen Shake
    function shakeScreen() {
      const originalY = camera.position.y;
      let shakeCount = 0;
      const shakeInterval = setInterval(() => {
        camera.position.y = originalY + (Math.random() - 0.5) * 0.5;
        shakeCount++;
        if (shakeCount > 10) {
          camera.position.y = originalY;
          clearInterval(shakeInterval);
        }
      }, 50);
    }

    // Update Lives Display
    function updateLivesDisplay() {
      const hearts = '‚ù§Ô∏è'.repeat(gameState.lives);
      document.getElementById('lives').textContent = hearts || 'üíÄ';
    }

    // Update UI
    function updateUI() {
      document.getElementById('score').textContent = gameState.score;
      document.getElementById('distance').textContent = Math.floor(gameState.distance) + 'm';
      document.getElementById('starsCollected').textContent = gameState.stars + ' ‚≠ê';
    }

    // Game Loop
    let lastTime = Date.now();
    let obstacleTimer = 0;
    let starTimer = 0;
    let powerupTimer = 0;

    function gameLoop() {
      requestAnimationFrame(gameLoop);
      
      if (!gameState.playing) {
        renderer.render(scene, camera);
        return;
      }
      
      const now = Date.now();
      const delta = (now - lastTime) / 1000;
      lastTime = now;
      
      const moveSpeed = 0.15;
      if (keys['ArrowLeft'] || keys['a']) {
        boat.position.x = Math.max(-4.5, boat.position.x - moveSpeed);
      }
      if (keys['ArrowRight'] || keys['d']) {
        boat.position.x = Math.min(4.5, boat.position.x + moveSpeed);
      }
      
      gameState.distance += gameState.speed * 10;
      gameState.baseSpeed = 0.15 + (gameState.distance * 0.00001);
      if (!gameState.speedBoost.active) {
        gameState.speed = gameState.baseSpeed;
      }
      
      obstacles.forEach((obstacle, index) => {
        obstacle.position.z += gameState.speed;
        obstacle.rotation.y += 0.02;
        
        if (obstacle.position.z > 5) {
          scene.remove(obstacle);
          obstacles.splice(index, 1);
        }
      });
      
      collectibles.forEach((star, index) => {
        star.position.z += gameState.speed;
        star.rotation.y += 0.05;
        star.rotation.x += 0.03;
        
        if (star.position.z > 5) {
          scene.remove(star);
          collectibles.splice(index, 1);
          gameState.combo = 0;
          document.getElementById('comboDisplay').classList.remove('active');
        }
      });
      
      powerups.forEach((powerup, index) => {
        powerup.position.z += gameState.speed;
        powerup.rotation.y += 0.08;
        
        if (powerup.position.z > 5) {
          scene.remove(powerup);
          powerups.splice(index, 1);
        }
      });
      
      particles.forEach((particle, index) => {
        particle.position.add(particle.velocity);
        particle.velocity.y -= 0.01;
        particle.life -= delta * 1.5;
        particle.material.opacity = particle.life;
        
        if (particle.life <= 0) {
          scene.remove(particle);
          particles.splice(index, 1);
        }
      });
      
      laneMarkers.forEach(marker => {
        marker.position.z += gameState.speed;
        if (marker.position.z > 5) {
          marker.position.z -= 100;
        }
      });
      
      obstacleTimer += delta;
      const obstacleSpawnRate = Math.max(0.8, 1.5 - (gameState.distance * 0.0005));
      if (obstacleTimer > obstacleSpawnRate) {
        spawnObstacle();
        obstacleTimer = 0;
      }
      
      starTimer += delta;
      if (starTimer > 2.5) {
        spawnStar();
        starTimer = 0;
      }
      
      powerupTimer += delta;
      if (powerupTimer > 8) {
        spawnPowerup();
        powerupTimer = 0;
      }
      
      updatePowerups(delta);
      checkCollisions();
      checkMilestones();
      updateUI();
      
      renderer.render(scene, camera);
    }

    // Start Game
    function startGame() {
      document.getElementById('menuScreen').classList.add('hidden');
      soundManager.play('drive');
      
      gameState = {
        playing: true,
        score: 0,
        distance: 0,
        lives: 3,
        stars: 0,
        combo: 0,
        maxCombo: 0,
        speed: 0.15,
        baseSpeed: 0.15,
        shield: { active: false, duration: 0 },
        speedBoost: { active: false, duration: 0 },
        magnet: { active: false, duration: 0 },
        milestones: {
          distance100: false,
          distance500: false,
          distance1000: false,
          perfectRun: false,
          combo10: false
        },
        perfectRunTimer: 0,
        lastHitTime: Date.now()
      };
      
      obstacles.forEach(o => scene.remove(o));
      obstacles.length = 0;
      collectibles.forEach(c => scene.remove(c));
      collectibles.length = 0;
      powerups.forEach(p => scene.remove(p));
      powerups.length = 0;
      particles.forEach(p => scene.remove(p));
      particles.length = 0;
      
      boat.position.set(0, 0.5, 0);
      
      updateLivesDisplay();
      updateUI();
      document.getElementById('comboDisplay').classList.remove('active');
      document.getElementById('shieldDisplay').classList.add('inactive');
      document.getElementById('speedDisplay').classList.add('inactive');
      document.getElementById('magnetDisplay').classList.add('inactive');
      
      lastTime = Date.now();
    }

    // End Game
    function endGame() {
      gameState.playing = false;
      soundManager.play('wawawa');
      
      document.getElementById('finalDistance').textContent = Math.floor(gameState.distance);
      document.getElementById('finalScore').textContent = gameState.score;
      document.getElementById('finalStars').textContent = gameState.stars;
      document.getElementById('finalCombo').textContent = gameState.maxCombo;
      document.getElementById('gameOver').classList.add('active');
      
      if (gameState.score > 0) {
        showLeaderboardModal('boating-school', 'Boating School Chaos', gameState.score);
      }
    }

    // Restart Game
    function restartGame() {
      document.getElementById('gameOver').classList.remove('active');
      startGame();
    }

    // Back to Menu
    function backToMenu() {
      document.getElementById('gameOver').classList.remove('active');
      document.getElementById('menuScreen').classList.remove('hidden');
    }

    // Window Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    gameLoop();
  </script>
</body>
</html>