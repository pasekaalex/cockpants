<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>$COCKPANTS Survivors</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="../leaderboard.js"></script>
  <script src="../sounds.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @font-face {
      font-family: 'Krabby Patty';
      src: url('../Krabby Patty.ttf') format('truetype');
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { 
      background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0d1a2f 100%);
      overflow: hidden;
      font-family: 'Krabby Patty', Arial, sans-serif;
      touch-action: none;
      user-select: none;
    }
    #root { width: 100vw; height: 100vh; }
    
    .mobile-joystick {
      display: none;
      position: fixed;
      bottom: 100px;
      left: 20px;
      width: 120px;
      height: 120px;
      z-index: 1000;
    }
    
    .joystick-base {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      border: 3px solid rgba(255, 215, 0, 0.7);
      position: relative;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3), inset 0 0 15px rgba(0, 0, 0, 0.5);
    }
    
    .joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(145deg, rgba(255, 215, 0, 0.9), rgba(255, 165, 0, 0.8));
      border: 2px solid #FFD700;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.5);
    }
    
    @media (max-width: 768px) {
      .mobile-joystick.visible { display: block; }
    }
    
    @keyframes comboPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.08); }
    }
    
    @keyframes bossWarning {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      50% { transform: translate(-50%, -50%) scale(1.05); opacity: 0.95; }
    }

    @keyframes levelUpGlow {
      0%, 100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); }
      50% { box-shadow: 0 0 60px rgba(255, 215, 0, 0.9), 0 0 100px rgba(255, 215, 0, 0.4); }
    }

    @keyframes upgradeCardHover {
      0% { transform: translateY(0); }
      100% { transform: translateY(-5px); }
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .combo-display {
      animation: comboPulse 0.5s ease-in-out infinite;
    }
    
    .boss-warning {
      animation: bossWarning 0.5s ease-in-out infinite;
    }

    .upgrade-modal {
      animation: fadeInUp 0.3s ease-out;
    }

    .upgrade-card {
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .upgrade-card::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
      transform: rotate(45deg);
      transition: all 0.5s;
    }

    .upgrade-card:hover::before {
      left: 100%;
    }

    .upgrade-card:hover {
      transform: translateY(-5px) scale(1.02);
      box-shadow: 0 10px 30px rgba(255, 215, 0, 0.3);
    }

    .game-paused-overlay {
      backdrop-filter: blur(4px);
    }

    .stat-bar {
      position: relative;
      overflow: hidden;
    }

    .stat-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, transparent 100%);
      pointer-events: none;
    }

    .weapon-slot {
      transition: all 0.2s ease;
    }

    .weapon-slot:hover {
      transform: scale(1.1);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }

    .hud-panel {
      backdrop-filter: blur(10px);
      background: linear-gradient(135deg, rgba(0, 20, 40, 0.9), rgba(0, 10, 30, 0.95));
      border: 2px solid rgba(255, 215, 0, 0.6);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .game-canvas {
      box-shadow: 0 0 40px rgba(0, 150, 255, 0.2), inset 0 0 100px rgba(0, 100, 200, 0.1);
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const GAME_WIDTH = 900;
    const GAME_HEIGHT = 650;
    const PLAYER_SIZE = 44;
    const ENEMY_SIZE = 36;
    const BASE_PLAYER_SPEED = 3.0;
    const ENEMY_SPEED_MULT = 0.5; // Reduced from 0.6 to make enemies slower

    const WEAPONS = {
      spatula: { damage: 25, cooldown: 600, speed: 9, color: '#FFD700', name: 'Krusty Spatula', emoji: 'ðŸ³', pierce: 1 },
      bubble: { damage: 15, cooldown: 250, speed: 7, color: '#87CEEB', name: 'Bubble Wand', emoji: 'ðŸ«§', pierce: 2 },
      clarinet: { damage: 50, cooldown: 1200, speed: 12, color: '#8B4513', name: 'Clarinet Blast', emoji: 'ðŸŽµ', pierce: 3 },
      jellyNet: { damage: 30, cooldown: 450, speed: 8, color: '#FF69B4', name: 'Jellyfish Net', emoji: 'ðŸª¼', pierce: 1 },
      karate: { damage: 70, cooldown: 1500, speed: 14, color: '#FF4500', name: 'Karate Chop', emoji: 'ðŸ¥‹', pierce: 5 },
      pattyBlast: { damage: 40, cooldown: 750, speed: 10, color: '#CD853F', name: 'Krabby Patty', emoji: 'ðŸ”', pierce: 2 },
    };

    const ENEMIES = {
      plankton: { hp: 15, speed: 1.8, xp: 3, color: '#228B22', name: 'Plankton', scale: 0.6 },
      krabs: { hp: 80, speed: 0.9, xp: 20, color: '#DC143C', name: 'Mr. Krabs', scale: 1.2 },
      squidward: { hp: 40, speed: 1.1, xp: 10, color: '#40E0D0', name: 'Squidward', scale: 1.0 },
      patrick: { hp: 120, speed: 0.6, xp: 25, color: '#FFB6C1', name: 'Patrick', scale: 1.3 },
      sandy: { hp: 60, speed: 1.4, xp: 15, color: '#DEB887', name: 'Sandy', scale: 1.0 },
      doodlebob: { hp: 200, speed: 0.8, xp: 50, color: '#FFFFFF', name: 'DoodleBob', scale: 1.4, boss: true },
    };

    const UPGRADE_TYPES = [
      { stat: 'damage', emoji: 'âš”ï¸', desc: '+15% Damage', subdesc: 'Hit harder!' },
      { stat: 'attackSpeed', emoji: 'ðŸ”¥', desc: '+12% Attack Speed', subdesc: 'Fire faster!' },
      { stat: 'projectileSize', emoji: 'ðŸ’¥', desc: '+15% Projectile Size', subdesc: 'Bigger hits!' },
      { stat: 'pierce', emoji: 'ðŸ—¡ï¸', desc: '+1 Pierce', subdesc: 'Hit more enemies!' },
      { stat: 'speed', emoji: 'âš¡', desc: '+10% Move Speed', subdesc: 'Gotta go fast!' },
      { stat: 'maxHp', emoji: 'â¤ï¸', desc: '+40 Max HP', subdesc: 'More tankiness!' },
      { stat: 'armor', emoji: 'ðŸ›¡ï¸', desc: '+3 Armor', subdesc: 'Take less damage!' },
      { stat: 'pickupRange', emoji: 'ðŸ§²', desc: '+25% Pickup Range', subdesc: 'Vacuum XP!' },
    ];
    
    // Weapon unlock upgrades (can appear in level-up choices)
    const WEAPON_UPGRADES = [
      { weapon: 'bubble', emoji: 'ðŸ«§', desc: 'Bubble Wand', subdesc: 'Fast bubbles!' },
      { weapon: 'clarinet', emoji: 'ðŸŽµ', desc: 'Clarinet Blast', subdesc: 'Powerful sound!' },
      { weapon: 'jellyNet', emoji: 'ðŸª¼', desc: 'Jellyfish Net', subdesc: 'Catch em all!' },
      { weapon: 'karate', emoji: 'ðŸ¥‹', desc: 'Karate Chop', subdesc: 'High damage!' },
      { weapon: 'pattyBlast', emoji: 'ðŸ”', desc: 'Krabby Patty', subdesc: 'Delicious!' },
    ];

    function CockpantsSurvivors() {
      const canvasRef = useRef(null);
      const [gameState, setGameState] = useState('menu');
      const [score, setScore] = useState(0);
      const [level, setLevel] = useState(1);
      const [xp, setXp] = useState(0);
      const [xpToLevel, setXpToLevel] = useState(12); // Easier to level up
      const [time, setTime] = useState(0);
      const [kills, setKills] = useState(0);
      const [showUpgrade, setShowUpgrade] = useState(false);
      const [upgradeOptions, setUpgradeOptions] = useState([]);
      const [weapons, setWeapons] = useState([]);
      const [playerStats, setPlayerStats] = useState({ speedBonus: 1, maxHp: 350, hp: 350, pickupRange: 60, armor: 0 });
      const [screenShake, setScreenShake] = useState(0);
      const [combo, setCombo] = useState(0);
      const [comboTimer, setComboTimer] = useState(0);
      const [bossWarning, setBossWarning] = useState(false);
      const gameOverRef = useRef(false);
      const touchRef = useRef({ active: false, startX: 0, startY: 0, dx: 0, dy: 0 });
      const soundManagerRef = useRef(null);
      const levelUpQueueRef = useRef(0); // Queue for pending level-ups

      const gameRef = useRef({
        player: { x: 0, y: 0, facing: 1 },
        enemies: [],
        projectiles: [],
        xpOrbs: [],
        chests: [],
        particles: [],
        damageNumbers: [],
        keys: {},
        lastShot: {},
        camera: { x: 0, y: 0 },
        lastBossSpawn: 0,
      });
      
      // Particle system
      const spawnParticles = useCallback((x, y, count, color, speed = 3) => {
        const game = gameRef.current;
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
          game.particles.push({
            x, y,
            vx: Math.cos(angle) * speed * (0.5 + Math.random()),
            vy: Math.sin(angle) * speed * (0.5 + Math.random()),
            life: 30 + Math.random() * 20,
            maxLife: 50,
            color: color || '#FFD700',
            size: 3 + Math.random() * 4,
          });
        }
      }, []);
      
      // Initialize sound manager
      useEffect(() => {
        if (typeof SoundManager !== 'undefined') {
          soundManagerRef.current = new SoundManager();
          soundManagerRef.current.loadAll({
            hit: '../audio/scream.mp3',
            kill: '../audio/victory.mp3',
            levelup: '../audio/ohyeah.mp3',
            pickup: '../audio/money.mp3',
          });
        }
      }, []);

      const generateUpgrades = useCallback(() => {
        const allOptions = [...UPGRADE_TYPES];
        
        // Add weapon unlocks if player has less than 6 weapons
        if (weapons.length < 6) {
          const availableWeapons = WEAPON_UPGRADES.filter(w => 
            !weapons.some(owned => owned.name === WEAPONS[w.weapon].name)
          );
          if (availableWeapons.length > 0) {
            // 30% chance to include a weapon unlock in options
            if (Math.random() < 0.3) {
              const weaponUpgrade = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
              allOptions.push({
                stat: 'weapon',
                weapon: weaponUpgrade.weapon,
                emoji: weaponUpgrade.emoji,
                desc: weaponUpgrade.desc,
                subdesc: weaponUpgrade.subdesc
              });
            }
          }
        }
        
        const shuffled = allOptions.sort(() => Math.random() - 0.5);
        setUpgradeOptions(shuffled.slice(0, 3));
      }, [weapons]);

      const selectUpgrade = (upgrade) => {
        if (upgrade.stat === 'weapon' && upgrade.weapon) {
          // Unlock new weapon
          const weapon = WEAPONS[upgrade.weapon];
          if (weapon && weapons.length < 6) {
            setWeapons(prev => [...prev, { ...weapon, level: 1, damageBonus: 1, cooldownBonus: 1, sizeBonus: 1 }]);
          }
        } else if (upgrade.stat === 'damage') {
          setWeapons(prev => prev.map(w => ({ ...w, damageBonus: (w.damageBonus || 1) * 1.15 })));
        } else if (upgrade.stat === 'attackSpeed') {
          setWeapons(prev => prev.map(w => ({ ...w, cooldownBonus: (w.cooldownBonus || 1) * 0.88 })));
        } else if (upgrade.stat === 'projectileSize') {
          setWeapons(prev => prev.map(w => ({ ...w, sizeBonus: (w.sizeBonus || 1) * 1.15 })));
        } else if (upgrade.stat === 'pierce') {
          setWeapons(prev => prev.map(w => ({ ...w, pierce: (w.pierce || 1) + 1 })));
        } else if (upgrade.stat === 'speed') {
          setPlayerStats(prev => ({ ...prev, speedBonus: Math.min(prev.speedBonus * 1.1, 1.5) }));
        } else if (upgrade.stat === 'maxHp') {
          setPlayerStats(prev => ({ ...prev, maxHp: prev.maxHp + 40, hp: prev.hp + 40 }));
        } else if (upgrade.stat === 'armor') {
          setPlayerStats(prev => ({ ...prev, armor: prev.armor + 3 }));
        } else if (upgrade.stat === 'pickupRange') {
          setPlayerStats(prev => ({ ...prev, pickupRange: prev.pickupRange * 1.25 }));
        }
        
        setShowUpgrade(false);
        
        // Process queued level-ups
        if (levelUpQueueRef.current > 0) {
          levelUpQueueRef.current--;
          setTimeout(() => {
            // Check if we have enough XP for the queued level-up
            setXp(prev => {
              const currentXpToLevel = xpToLevel;
              if (prev >= currentXpToLevel) {
                const excessXp = prev - currentXpToLevel;
                setLevel(l => l + 1);
                setXpToLevel(x => Math.floor(x * 1.2));
                setShowUpgrade(true);
                generateUpgrades();
                if (soundManagerRef.current) {
                  soundManagerRef.current.play('levelup', { volume: 0.5 });
                }
                // Check if excess XP triggers more level-ups
                let remainingXp = excessXp;
                let queuedLevels = 0;
                let nextXpToLevel = Math.floor(currentXpToLevel * 1.2);
                while (remainingXp >= nextXpToLevel && levelUpQueueRef.current > 0) {
                  remainingXp -= nextXpToLevel;
                  queuedLevels++;
                  levelUpQueueRef.current--;
                  nextXpToLevel = Math.floor(nextXpToLevel * 1.2);
                }
                if (queuedLevels > 0) {
                  levelUpQueueRef.current += queuedLevels;
                }
                return remainingXp;
              }
              return prev;
            });
          }, 300);
        }
      };

      const addWeaponFromChest = useCallback((weaponKey) => {
        const weapon = WEAPONS[weaponKey];
        if (!weapon) return;
        setWeapons(prev => {
          const existing = prev.find(w => w.name === weapon.name);
          if (existing) {
            return prev.map(w => w.name === weapon.name ? { ...w, level: w.level + 1, damageBonus: (w.damageBonus || 1) * 1.2 } : w);
          } else if (prev.length < 6) {
            return [...prev, { ...weapon, level: 1, damageBonus: 1, cooldownBonus: 1, sizeBonus: 1 }];
          }
          return prev.map(w => ({ ...w, damageBonus: (w.damageBonus || 1) * 1.1 }));
        });
      }, []);

      const startGame = () => {
        const currentKeys = gameRef.current.keys || {};
        gameOverRef.current = false;
        setScore(0);
        setLevel(1);
        setXp(0);
        setXpToLevel(12);
        setTime(0);
        setKills(0);
        setCombo(0);
        setShowUpgrade(false);
        levelUpQueueRef.current = 0;
        setWeapons([{ ...WEAPONS.spatula, level: 1, damageBonus: 1, cooldownBonus: 1, sizeBonus: 1 }]);
        setPlayerStats({ speedBonus: 1, maxHp: 350, hp: 350, pickupRange: 60, armor: 0 }); // Increased starting HP
        gameRef.current = {
          player: { x: 0, y: 0, facing: 1 },
          enemies: [],
          projectiles: [],
          xpOrbs: [],
          chests: [],
          particles: [],
          damageNumbers: [],
          keys: currentKeys,
          lastShot: {},
          camera: { x: 0, y: 0 },
          lastBossSpawn: 0,
        };
        touchRef.current = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
        setGameState('playing');
      };

      // Keyboard controls
      useEffect(() => {
        const handleKeyDown = (e) => { gameRef.current.keys[e.key.toLowerCase()] = true; };
        const handleKeyUp = (e) => { gameRef.current.keys[e.key.toLowerCase()] = false; };
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        return () => {
          window.removeEventListener('keydown', handleKeyDown);
          window.removeEventListener('keyup', handleKeyUp);
        };
      }, []);

      // Mobile joystick
      useEffect(() => {
        if (gameState !== 'playing') return;
        const joystick = document.getElementById('joystickBase');
        if (!joystick) return;

        const handleTouchStart = (e) => {
          e.preventDefault();
          const rect = joystick.getBoundingClientRect();
          touchRef.current.active = true;
          touchRef.current.startX = rect.left + rect.width / 2;
          touchRef.current.startY = rect.top + rect.height / 2;
        };
        const handleTouchMove = (e) => {
          if (!touchRef.current.active) return;
          e.preventDefault();
          const touch = e.touches[0];
          const dx = touch.clientX - touchRef.current.startX;
          const dy = touch.clientY - touchRef.current.startY;
          const dist = Math.hypot(dx, dy);
          const maxDist = 40;
          if (dist > 5) {
            touchRef.current.dx = (dx / Math.max(dist, maxDist)) * Math.min(dist, maxDist) / maxDist;
            touchRef.current.dy = (dy / Math.max(dist, maxDist)) * Math.min(dist, maxDist) / maxDist;
            const stick = document.getElementById('joystickStick');
            if (stick) {
              stick.style.transform = `translate(calc(-50% + ${touchRef.current.dx * 30}px), calc(-50% + ${touchRef.current.dy * 30}px))`;
            }
          }
        };
        const handleTouchEnd = () => {
          touchRef.current.active = false;
          touchRef.current.dx = 0;
          touchRef.current.dy = 0;
          const stick = document.getElementById('joystickStick');
          if (stick) stick.style.transform = 'translate(-50%, -50%)';
        };

        joystick.addEventListener('touchstart', handleTouchStart, { passive: false });
        window.addEventListener('touchmove', handleTouchMove, { passive: false });
        window.addEventListener('touchend', handleTouchEnd);
        return () => {
          joystick.removeEventListener('touchstart', handleTouchStart);
          window.removeEventListener('touchmove', handleTouchMove);
          window.removeEventListener('touchend', handleTouchEnd);
        };
      }, [gameState]);

      // Show leaderboard on game over
      useEffect(() => {
        if (gameState === 'gameover' && typeof showLeaderboardModal === 'function') {
          setTimeout(() => showLeaderboardModal('survivors', '$COCKPANTS Survivors', score), 500);
        }
      }, [gameState, score]);

      // Main game loop
      useEffect(() => {
        if (gameState !== 'playing') return;
        gameOverRef.current = false;

        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let animationId;
        let lastUpdateTime = performance.now();
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS; // ~16.67ms per frame
        let spawnTimer = 0;
        let timeTimer = 0;

        const spawnEnemy = () => {
          const game = gameRef.current;
          const side = Math.floor(Math.random() * 4);
          let x, y;
          const offset = 150;
          if (side === 0) { x = game.player.x + (Math.random() - 0.5) * GAME_WIDTH; y = game.player.y - GAME_HEIGHT/2 - offset; }
          else if (side === 1) { x = game.player.x + GAME_WIDTH/2 + offset; y = game.player.y + (Math.random() - 0.5) * GAME_HEIGHT; }
          else if (side === 2) { x = game.player.x + (Math.random() - 0.5) * GAME_WIDTH; y = game.player.y + GAME_HEIGHT/2 + offset; }
          else { x = game.player.x - GAME_WIDTH/2 - offset; y = game.player.y + (Math.random() - 0.5) * GAME_HEIGHT; }

          let pool = ['plankton'];
          if (time > 15) pool.push('squidward');
          if (time > 30) pool.push('krabs');
          if (time > 45) pool.push('sandy');
          if (time > 60) pool.push('patrick');
          
          const typeKey = pool[Math.floor(Math.random() * pool.length)];
          const template = ENEMIES[typeKey];
          const isElite = Math.random() < 0.05;
          const mult = isElite ? 3 : 1;
          
          game.enemies.push({
            ...template,
            x, y,
            hp: template.hp * mult,
            maxHp: template.hp * mult,
            type: typeKey,
            isElite,
            hit: 0,
          });
        };

        const shootProjectiles = () => {
          const game = gameRef.current;
          const now = Date.now();
          
          weapons.forEach(weapon => {
            const cooldown = weapon.cooldown * (weapon.cooldownBonus || 1);
            if (!game.lastShot[weapon.name] || now - game.lastShot[weapon.name] > cooldown) {
              let nearest = null;
              let nearestDist = 500;
              game.enemies.forEach(e => {
                const dist = Math.hypot(e.x - game.player.x, e.y - game.player.y);
                if (dist < nearestDist) { nearestDist = dist; nearest = e; }
              });
              
              if (nearest) {
                game.lastShot[weapon.name] = now;
                const angle = Math.atan2(nearest.y - game.player.y, nearest.x - game.player.x);
                const shots = weapon.level >= 5 ? 3 : weapon.level >= 3 ? 2 : 1;
                
                for (let i = 0; i < shots; i++) {
                  const shotAngle = angle + (i - (shots - 1) / 2) * 0.15;
                  game.projectiles.push({
                    x: game.player.x, y: game.player.y,
                    vx: Math.cos(shotAngle) * weapon.speed,
                    vy: Math.sin(shotAngle) * weapon.speed,
                    damage: weapon.damage * (weapon.damageBonus || 1),
                    color: weapon.color,
                    life: 120,
                    pierce: weapon.pierce + Math.floor(weapon.level / 2),
                    size: (6 + weapon.level) * (weapon.sizeBonus || 1),
                    hit: [],
                  });
                }
              }
            }
          });
        };

        const gameLoop = (currentTime) => {
          // Always render, but pause game logic when upgrade screen is shown
          if (showUpgrade) {
            // Still render the game in background (frozen state)
            renderGame();
            animationId = requestAnimationFrame(gameLoop);
            return;
          }
          
          if (gameState !== 'playing') {
            animationId = requestAnimationFrame(gameLoop);
            return;
          }
          if (gameOverRef.current) return;
          
          if (!currentTime) currentTime = performance.now();
          
          // FIXED TIMESTEP - Only update game logic at exactly 60fps
          const elapsed = currentTime - lastUpdateTime;
          
          // Only update if enough time has passed (16.67ms for 60fps)
          if (elapsed >= FRAME_TIME) {
            // Cap to prevent huge jumps
            const cappedElapsed = Math.min(elapsed, FRAME_TIME * 3); // Max 3 frames worth
            const updateCount = Math.floor(cappedElapsed / FRAME_TIME);
            
            // Run game updates
            for (let i = 0; i < updateCount; i++) {
              updateGame(1.0); // Always use 1.0 delta
            }
            
            lastUpdateTime = currentTime - (elapsed % FRAME_TIME);
          }
          
          // Always render (smooth visuals)
          renderGame();
          
          if (!gameOverRef.current) {
            animationId = requestAnimationFrame(gameLoop);
          }
        };
        
        const updateGame = (delta) => {
          
          const game = gameRef.current;
          const keys = game.keys;
          
          // Player movement
          let dx = 0, dy = 0;
          if (keys['w'] || keys['arrowup']) dy -= 1;
          if (keys['s'] || keys['arrowdown']) dy += 1;
          if (keys['a'] || keys['arrowleft']) dx -= 1;
          if (keys['d'] || keys['arrowright']) dx += 1;
          
          if (touchRef.current.active) {
            dx = touchRef.current.dx;
            dy = touchRef.current.dy;
          }
          
          if (dx !== 0 || dy !== 0) {
            const len = Math.hypot(dx, dy);
            const speed = BASE_PLAYER_SPEED * (playerStats.speedBonus || 1);
            game.player.x += (dx / len) * speed * delta;
            game.player.y += (dy / len) * speed * delta;
            game.player.facing = dx !== 0 ? Math.sign(dx) : game.player.facing;
          }
          
          game.camera.x = game.player.x - GAME_WIDTH / 2;
          game.camera.y = game.player.y - GAME_HEIGHT / 2;
          
          // Spawn enemies (easier - slower spawn rate)
          spawnTimer += delta;
          const spawnRate = Math.max(35, 60 - time * 0.15); // Slower spawn rate
          if (spawnTimer > spawnRate) {
            spawnTimer = 0;
            const count = Math.min(1 + Math.floor(time / 30), 2); // Fewer enemies at once
            for (let i = 0; i < count; i++) spawnEnemy();
          }
          
          // Boss spawn every 2 minutes
          if (time > 0 && time >= 120 && time - game.lastBossSpawn >= 120) {
            game.lastBossSpawn = time;
            const bossTypes = ['doodlebob', 'krabs', 'patrick'];
            const bossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
            const enemy = ENEMIES[bossType];
            const angle = Math.random() * Math.PI * 2;
            const dist = 500;
            game.enemies.push({
              ...enemy,
              x: game.player.x + Math.cos(angle) * dist,
              y: game.player.y + Math.sin(angle) * dist,
              hp: enemy.hp * 3,
              maxHp: enemy.hp * 3,
              isElite: true,
              isBoss: true,
              mult: 3,
            });
            setBossWarning(true);
            setTimeout(() => setBossWarning(false), 3000);
            setScreenShake(8); // Reduced from 20
          }
          
          // Time - count fixed updates, 60 updates = 1 second
          timeTimer += delta;
          if (timeTimer >= 60) { 
            timeTimer = 0; 
            setTime(t => t + 1); 
          }
          
          // Shoot
          shootProjectiles();
          
          // Update projectiles
          game.projectiles = game.projectiles.filter(p => {
            p.x += p.vx * delta;
            p.y += p.vy * delta;
            p.life -= delta;
            return p.life > 0 && p.pierce > 0;
          });
          
          // Update enemies
          game.enemies.forEach(e => {
            const angle = Math.atan2(game.player.y - e.y, game.player.x - e.x);
            e.x += Math.cos(angle) * e.speed * ENEMY_SPEED_MULT * delta;
            e.y += Math.sin(angle) * e.speed * ENEMY_SPEED_MULT * delta;
            if (e.hit > 0) e.hit -= delta;
          });
          
          // Projectile-enemy collision
          game.projectiles.forEach(p => {
            game.enemies.forEach(e => {
              if (p.pierce <= 0 || p.hit.includes(e)) return;
              const dist = Math.hypot(p.x - e.x, p.y - e.y);
              if (dist < ENEMY_SIZE * (e.scale || 1)) {
                const crit = Math.random() < 0.15;
                const dmg = crit ? p.damage * 2 : p.damage;
                e.hp -= dmg;
                e.hit = 8;
                p.pierce--;
                p.hit.push(e);
                
                game.damageNumbers.push({ x: e.x, y: e.y - 20, damage: Math.floor(dmg), life: 40, vy: -2 * delta, crit });
                
                if (e.hp <= 0) {
                  // Particle explosion on death
                  spawnParticles(e.x, e.y, 12, e.color, 5);
                  
                  // Drop XP
                  const orbCount = Math.ceil(e.xp / 5);
                  for (let i = 0; i < orbCount; i++) {
                    game.xpOrbs.push({ x: e.x + (Math.random() - 0.5) * 30, y: e.y + (Math.random() - 0.5) * 30, xp: Math.ceil(e.xp / orbCount) });
                  }
                  // Elite drops chest (also regular enemies have 10% chance)
                  if (e.isElite || Math.random() < 0.1) {
                    const weaponKeys = Object.keys(WEAPONS);
                    game.chests.push({ x: e.x, y: e.y, weapon: weaponKeys[Math.floor(Math.random() * weaponKeys.length)] });
                    setScreenShake(5); // Reduced from 15
                  }
                  setKills(k => k + 1);
                  setCombo(c => c + 1);
                  setComboTimer(120);
                  setScore(s => s + e.xp * 10 * (1 + combo * 0.1));
                }
              }
            });
          });
          game.enemies = game.enemies.filter(e => e.hp > 0);
          
          // Player-enemy collision
          game.enemies.forEach(e => {
            if (gameOverRef.current) return;
            const dist = Math.hypot(game.player.x - e.x, game.player.y - e.y);
            if (dist < (PLAYER_SIZE + ENEMY_SIZE * (e.scale || 1)) / 2) {
              const dmg = Math.max(0.3, 0.7 - playerStats.armor * 0.05) * delta; // Reduced damage (30% less)
              setScreenShake(3); // Reduced from 8 - much subtler
              if (soundManagerRef.current) {
                soundManagerRef.current.play('hit', { volume: 0.2 });
              }
              setPlayerStats(prev => {
                const newHp = prev.hp - dmg;
                if (newHp <= 0 && !gameOverRef.current) {
                  gameOverRef.current = true;
                  setGameState('gameover');
                  return { ...prev, hp: 0 };
                }
                return { ...prev, hp: Math.max(0, newHp) };
              });
            }
          });
          
          // Collect XP orbs - accumulate all XP first to prevent multiple level-ups
          let totalXpGained = 0;
          game.xpOrbs = game.xpOrbs.filter(orb => {
            const dist = Math.hypot(game.player.x - orb.x, game.player.y - orb.y);
            if (dist < playerStats.pickupRange) {
              const angle = Math.atan2(game.player.y - orb.y, game.player.x - orb.x);
              orb.x += Math.cos(angle) * 8 * delta;
              orb.y += Math.sin(angle) * 8 * delta;
            }
            if (dist < 25) {
              totalXpGained += orb.xp;
              return false; // Remove orb
            }
            return true;
          });
          
          // Apply XP gain once, after collecting all orbs
          if (totalXpGained > 0 && !showUpgrade) {
            setXp(prev => {
              const newXp = prev + totalXpGained;
              const currentXpToLevel = xpToLevel; // Capture current value
              
              if (newXp >= currentXpToLevel) {
                const excessXp = newXp - currentXpToLevel;
                // Trigger level-up
                setLevel(l => l + 1);
                setXpToLevel(x => Math.floor(x * 1.2));
                setShowUpgrade(true);
                generateUpgrades();
                if (soundManagerRef.current) {
                  soundManagerRef.current.play('levelup', { volume: 0.5 });
                }
                // Check if excess XP triggers another level-up (queue it)
                let remainingXp = excessXp;
                let queuedLevels = 0;
                let nextXpToLevel = Math.floor(currentXpToLevel * 1.2);
                while (remainingXp >= nextXpToLevel) {
                  remainingXp -= nextXpToLevel;
                  queuedLevels++;
                  nextXpToLevel = Math.floor(nextXpToLevel * 1.2);
                }
                if (queuedLevels > 0) {
                  levelUpQueueRef.current += queuedLevels;
                }
                return remainingXp; // Keep excess XP
              }
              return newXp;
            });
          } else if (totalXpGained > 0) {
            // If upgrade screen is showing, just add XP without checking for level-up
            setXp(prev => prev + totalXpGained);
          }
          
          // Collect chests
          game.chests = game.chests.filter(chest => {
            const dist = Math.hypot(game.player.x - chest.x, game.player.y - chest.y);
            if (dist < 40) {
              spawnParticles(chest.x, chest.y, 20, '#FFD700', 6);
              addWeaponFromChest(chest.weapon);
              setScore(s => s + 500);
              if (soundManagerRef.current) {
                soundManagerRef.current.play('pickup', { volume: 0.4 });
              }
              return false;
            }
            return true;
          });
          
          // Update damage numbers
          game.damageNumbers = game.damageNumbers.filter(d => {
            d.y += d.vy * delta;
            d.life -= delta;
            return d.life > 0;
          });
          
          // Update particles
          game.particles = game.particles.filter(p => {
            p.x += p.vx * delta;
            p.y += p.vy * delta;
            p.vy += 0.1 * delta; // Gravity
            p.life -= delta;
            return p.life > 0;
          });
          
          // Update combo timer
          if (comboTimer > 0) {
            setComboTimer(prev => {
              const newTimer = prev - delta;
              if (newTimer <= 0) {
                setCombo(0);
                return 0;
              }
              return newTimer;
            });
          }
          
          // Update screen shake
          if (screenShake > 0) {
            setScreenShake(prev => Math.max(0, prev - delta));
          }
        };
        
        const renderGame = () => {
          const game = gameRef.current;
          
          // Screen shake - very subtle
          const shakeIntensity = Math.min(screenShake * 0.5, 4); // Cap shake intensity
          const shakeX = screenShake > 0 ? (Math.random() - 0.5) * shakeIntensity : 0;
          const shakeY = screenShake > 0 ? (Math.random() - 0.5) * shakeIntensity : 0;
          
          ctx.save();
          ctx.translate(shakeX, shakeY);
          
          // RENDER - Enhanced underwater background
          const bgGradient = ctx.createRadialGradient(GAME_WIDTH/2, GAME_HEIGHT/2, 0, GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH);
          bgGradient.addColorStop(0, '#0d2847');
          bgGradient.addColorStop(0.5, '#0a1e3a');
          bgGradient.addColorStop(1, '#061428');
          ctx.fillStyle = bgGradient;
          ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
          
          const now = performance.now();
          
          // Animated underwater caustics (light rays)
          ctx.globalAlpha = 0.03;
          for (let i = 0; i < 5; i++) {
            const rayX = ((i * 200 + now / 30) % (GAME_WIDTH + 200)) - 100;
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.moveTo(rayX, 0);
            ctx.lineTo(rayX + 80, GAME_HEIGHT);
            ctx.lineTo(rayX + 120, GAME_HEIGHT);
            ctx.lineTo(rayX + 40, 0);
            ctx.closePath();
            ctx.fill();
          }
          ctx.globalAlpha = 1;
          
          // Animated background bubbles/particles
          ctx.fillStyle = 'rgba(135, 206, 250, 0.12)';
          for (let i = 0; i < 40; i++) {
            const bx = ((i * 137 + now / 60) % (GAME_WIDTH + 100)) - 50;
            const by = ((i * 89 + now / 40) % (GAME_HEIGHT + 100)) - 50;
            const size = 1.5 + (i % 4);
            ctx.beginPath();
            ctx.arc(bx, by, size, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Floating kelp/seaweed in background
          ctx.fillStyle = 'rgba(34, 139, 34, 0.1)';
          for (let i = 0; i < 8; i++) {
            const kelpX = (i * 120) - (game.camera.x * 0.1) % 120;
            const sway = Math.sin(now / 1000 + i) * 10;
            ctx.beginPath();
            ctx.moveTo(kelpX, GAME_HEIGHT);
            ctx.quadraticCurveTo(kelpX + sway, GAME_HEIGHT - 80, kelpX + sway * 0.5, GAME_HEIGHT - 150);
            ctx.quadraticCurveTo(kelpX, GAME_HEIGHT - 100, kelpX, GAME_HEIGHT);
            ctx.fill();
          }
          
          // Grid with gradient fade
          const gridSize = 60;
          for (let x = -game.camera.x % gridSize; x < GAME_WIDTH; x += gridSize) {
            const distFromCenter = Math.abs(x - GAME_WIDTH / 2) / (GAME_WIDTH / 2);
            ctx.strokeStyle = `rgba(0, 191, 255, ${0.08 * (1 - distFromCenter * 0.5)})`;
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, GAME_HEIGHT); ctx.stroke();
          }
          for (let y = -game.camera.y % gridSize; y < GAME_HEIGHT; y += gridSize) {
            const distFromCenter = Math.abs(y - GAME_HEIGHT / 2) / (GAME_HEIGHT / 2);
            ctx.strokeStyle = `rgba(0, 191, 255, ${0.08 * (1 - distFromCenter * 0.5)})`;
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(GAME_WIDTH, y); ctx.stroke();
          }
          
          // XP orbs (glowing gems)
          game.xpOrbs.forEach(orb => {
            const sx = orb.x - game.camera.x, sy = orb.y - game.camera.y;
            if (sx < -20 || sx > GAME_WIDTH + 20 || sy < -20 || sy > GAME_HEIGHT + 20) return;
            
            // Outer glow
            const orbGlow = ctx.createRadialGradient(sx, sy, 0, sx, sy, 12);
            orbGlow.addColorStop(0, 'rgba(255, 215, 0, 0.6)');
            orbGlow.addColorStop(0.5, 'rgba(255, 215, 0, 0.2)');
            orbGlow.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = orbGlow;
            ctx.beginPath();
            ctx.arc(sx, sy, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Main orb with pulsing
            const pulse = 1 + Math.sin(now / 200 + orb.x) * 0.15;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(sx, sy, 5 * pulse, 7 * pulse, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
            ctx.beginPath();
            ctx.ellipse(sx - 2, sy - 3, 2, 2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Leaf
            ctx.fillStyle = '#32CD32';
            ctx.beginPath();
            ctx.ellipse(sx, sy - 9 * pulse, 2, 4, 0, 0, Math.PI * 2);
            ctx.fill();
          });
          
          // Chests with enhanced visuals
          game.chests.forEach(chest => {
            const sx = chest.x - game.camera.x, sy = chest.y - game.camera.y;
            if (sx < -30 || sx > GAME_WIDTH + 30 || sy < -30 || sy > GAME_HEIGHT + 30) return;
            
            // Glow effect
            const chestGlow = ctx.createRadialGradient(sx, sy, 0, sx, sy, 30);
            chestGlow.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
            chestGlow.addColorStop(0.5, 'rgba(255, 215, 0, 0.15)');
            chestGlow.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = chestGlow;
            ctx.beginPath();
            ctx.arc(sx, sy, 30, 0, Math.PI * 2);
            ctx.fill();
            
            // Chest body
            const chestGradient = ctx.createLinearGradient(sx - 14, sy - 10, sx + 14, sy + 10);
            chestGradient.addColorStop(0, '#A0522D');
            chestGradient.addColorStop(0.5, '#8B4513');
            chestGradient.addColorStop(1, '#654321');
            ctx.fillStyle = chestGradient;
            ctx.fillRect(sx - 14, sy - 10, 28, 20);
            
            // Chest lid
            ctx.fillStyle = '#A0522D';
            ctx.beginPath();
            ctx.ellipse(sx, sy - 10, 14, 5, 0, Math.PI, Math.PI * 2);
            ctx.fill();
            
            // Gold trim
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.strokeRect(sx - 14, sy - 10, 28, 20);
            
            // Lock
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(sx, sy, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(sx, sy + 1, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Weapon emoji floating above
            const float = Math.sin(now / 300) * 3;
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(WEAPONS[chest.weapon]?.emoji || 'ðŸ“¦', sx, sy - 20 + float);
          });
          
          // Draw Enemies with Art
          const drawEnemy = (ctx, e, sx, sy) => {
            const size = ENEMY_SIZE * (e.scale || 1);
            const hitFlash = e.hit > 0;
            
            ctx.save();
            ctx.translate(sx, sy);
            if (hitFlash) ctx.filter = 'brightness(2)';
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, size/2, size/2, size/4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            switch(e.type) {
              case 'plankton':
                // Green plankton body
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.ellipse(0, 0, size/3, size/2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Red eye
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(0, -size/6, size/4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(0, -size/6, size/8, 0, Math.PI * 2);
                ctx.fill();
                // Antennae
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-3, -size/2);
                ctx.lineTo(-5, -size/2 - 8);
                ctx.moveTo(3, -size/2);
                ctx.lineTo(5, -size/2 - 8);
                ctx.stroke();
                break;
                
              case 'krabs':
                // Red crab body
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.ellipse(0, 0, size/2, size/2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                // Claws
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.ellipse(-size/2 - 8, 0, 10, 7, -0.3, 0, Math.PI * 2);
                ctx.ellipse(size/2 + 8, 0, 10, 7, 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#FFFF00';
                ctx.beginPath();
                ctx.arc(-10, -size/2 - 8, 5, 0, Math.PI * 2);
                ctx.arc(10, -size/2 - 8, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-10, -size/2 - 8, 2, 0, Math.PI * 2);
                ctx.arc(10, -size/2 - 8, 2, 0, Math.PI * 2);
                ctx.fill();
                break;
                
              case 'squidward':
                // Teal squidward head
                ctx.fillStyle = '#40E0D0';
                ctx.beginPath();
                ctx.ellipse(0, -size/4, size/3, size/2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Body
                ctx.fillStyle = '#2F9F9F';
                ctx.beginPath();
                ctx.ellipse(0, size/6, size/5, size/3, 0, 0, Math.PI * 2);
                ctx.fill();
                // Nose
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(-12, -size/2, 8, 6);
                ctx.fillRect(4, -size/2, 8, 6);
                ctx.fillStyle = '#000';
                ctx.fillRect(-10, -size/2 + 2, 4, 4);
                ctx.fillRect(6, -size/2 + 2, 4, 4);
                // Mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, size/4, 6, 1.1 * Math.PI, 1.9 * Math.PI);
                ctx.stroke();
                break;
                
              case 'patrick':
                // Pink starfish
                ctx.fillStyle = '#FFB6C1';
                const points = 5;
                ctx.beginPath();
                for (let i = 0; i < points * 2; i++) {
                  const radius = i % 2 === 0 ? size/1.8 : size/3.5;
                  const angle = (i * Math.PI / points) - Math.PI / 2;
                  const px = Math.cos(angle) * radius;
                  const py = Math.sin(angle) * radius;
                  if (i === 0) ctx.moveTo(px, py);
                  else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                // Belly
                ctx.fillStyle = '#32CD32';
                ctx.beginPath();
                ctx.ellipse(0, size/4, size/3, size/5, 0, 0, Math.PI);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(-6, -size/6, 5, 0, Math.PI * 2);
                ctx.arc(6, -size/6, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-6, -size/6, 2, 0, Math.PI * 2);
                ctx.arc(6, -size/6, 2, 0, Math.PI * 2);
                ctx.fill();
                // Mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, size/8, 8, 0, Math.PI);
                ctx.stroke();
                break;
                
              case 'sandy':
                // Tan squirrel
                ctx.fillStyle = '#DEB887';
                ctx.beginPath();
                ctx.arc(0, 0, size/2.5, 0, Math.PI * 2);
                ctx.fill();
                // Goggles
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                ctx.stroke();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-5, -3, 3, 0, Math.PI * 2);
                ctx.arc(5, -3, 3, 0, Math.PI * 2);
                ctx.fill();
                // Cheeks
                ctx.fillStyle = '#FF9999';
                ctx.beginPath();
                ctx.arc(-10, 3, 4, 0, Math.PI * 2);
                ctx.arc(10, 3, 4, 0, Math.PI * 2);
                ctx.fill();
                break;
                
              default:
                // Generic enemy
                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.filter = 'none';
            ctx.restore();
            
            // HP bar
            if (e.type !== 'plankton') {
              const barW = size * 1.2;
              ctx.fillStyle = 'rgba(0,0,0,0.7)';
              ctx.fillRect(sx - barW/2, sy - size/2 - 12, barW, 6);
              ctx.fillStyle = e.hp / e.maxHp > 0.5 ? '#0F0' : e.hp / e.maxHp > 0.25 ? '#FF0' : '#F00';
              ctx.fillRect(sx - barW/2 + 1, sy - size/2 - 11, (barW - 2) * (e.hp / e.maxHp), 4);
            }
            
            // Elite crown
            if (e.isElite) {
              ctx.font = '16px Arial';
              ctx.textAlign = 'center';
              ctx.fillText('ðŸ‘‘', sx, sy - size/2 - 18);
            }
          };
          
          game.enemies.forEach(e => {
            const sx = e.x - game.camera.x, sy = e.y - game.camera.y;
            if (sx > -100 && sx < GAME_WIDTH + 100 && sy > -100 && sy < GAME_HEIGHT + 100) {
              if (e.isElite) {
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 20;
              }
              drawEnemy(ctx, e, sx, sy);
              ctx.shadowBlur = 0;
            }
          });
          
          // Projectiles with glow
          game.projectiles.forEach(p => {
            const sx = p.x - game.camera.x, sy = p.y - game.camera.y;
            if (sx < -50 || sx > GAME_WIDTH + 50 || sy < -50 || sy > GAME_HEIGHT + 50) return;
            
            // Outer glow
            const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, p.size);
            const colorRgb = p.color.match(/\d+/g);
            gradient.addColorStop(0, p.color);
            gradient.addColorStop(0.5, p.color.replace(')', ', 0.5)').replace('rgb', 'rgba'));
            gradient.addColorStop(1, p.color.replace(')', ', 0)').replace('rgb', 'rgba'));
            
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 15;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(sx, sy, p.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Core
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(sx, sy, p.size / 3, 0, Math.PI * 2);
            ctx.fill();
          });
          
          // Particles
          game.particles.forEach(p => {
            const sx = p.x - game.camera.x, sy = p.y - game.camera.y;
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(sx, sy, p.size * alpha, 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
          
          // Player (SpongeBob) - Better art
          const px = GAME_WIDTH / 2, py = GAME_HEIGHT / 2;
          const bobOffset = Math.sin(performance.now() / 150) * 3;
          
          ctx.save();
          ctx.translate(px, py + bobOffset);
          if (game.player.facing < 0) ctx.scale(-1, 1);
          
          // Shadow
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.beginPath();
          ctx.ellipse(0, 24, 16, 6, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Body gradient
          const bodyGradient = ctx.createLinearGradient(-20, -28, 20, 28);
          bodyGradient.addColorStop(0, '#FFE566');
          bodyGradient.addColorStop(0.5, '#FFD700');
          bodyGradient.addColorStop(1, '#E6B800');
          ctx.fillStyle = bodyGradient;
          // Rounded rectangle
          const r = 6;
          ctx.beginPath();
          ctx.moveTo(-20 + r, -28);
          ctx.lineTo(20 - r, -28);
          ctx.quadraticCurveTo(20, -28, 20, -28 + r);
          ctx.lineTo(20, 24 - r);
          ctx.quadraticCurveTo(20, 24, 20 - r, 24);
          ctx.lineTo(-20 + r, 24);
          ctx.quadraticCurveTo(-20, 24, -20, 24 - r);
          ctx.lineTo(-20, -28 + r);
          ctx.quadraticCurveTo(-20, -28, -20 + r, -28);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = '#CC9900';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Pants
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(-20, 12, 40, 16);
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(-20, 10, 40, 5);
          
          // Shirt
          ctx.fillStyle = '#FFF';
          ctx.beginPath();
          ctx.moveTo(-12, 10);
          ctx.lineTo(0, 16);
          ctx.lineTo(12, 10);
          ctx.lineTo(12, 12);
          ctx.lineTo(0, 18);
          ctx.lineTo(-12, 12);
          ctx.closePath();
          ctx.fill();
          
          // Tie
          ctx.fillStyle = '#FF0000';
          ctx.beginPath();
          ctx.moveTo(-3, 12);
          ctx.lineTo(3, 12);
          ctx.lineTo(4, 20);
          ctx.lineTo(0, 22);
          ctx.lineTo(-4, 20);
          ctx.closePath();
          ctx.fill();
          
          // Eyes
          ctx.fillStyle = '#FFF';
          ctx.beginPath();
          ctx.ellipse(-7, -10, 9, 11, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(7, -10, 9, 11, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.ellipse(-7, -10, 9, 11, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.ellipse(7, -10, 9, 11, 0, 0, Math.PI * 2);
          ctx.stroke();
          
          // Pupils
          ctx.fillStyle = '#00BFFF';
          ctx.beginPath();
          ctx.arc(-7 + game.player.facing * 2, -10, 5, 0, Math.PI * 2);
          ctx.arc(7 + game.player.facing * 2, -10, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(-7 + game.player.facing * 2, -10, 2.5, 0, Math.PI * 2);
          ctx.arc(7 + game.player.facing * 2, -10, 2.5, 0, Math.PI * 2);
          ctx.fill();
          
          // Eye highlights
          ctx.fillStyle = '#FFF';
          ctx.beginPath();
          ctx.arc(-9, -12, 2, 0, Math.PI * 2);
          ctx.arc(5, -12, 2, 0, Math.PI * 2);
          ctx.fill();
          
          // Nose
          ctx.fillStyle = '#FFD700';
          ctx.beginPath();
          ctx.ellipse(0, -2, 4, 6, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#CC9900';
          ctx.lineWidth = 1;
          ctx.stroke();
          
          // Cheeks
          ctx.fillStyle = 'rgba(255, 150, 150, 0.4)';
          ctx.beginPath();
          ctx.ellipse(-14, 0, 5, 3, 0, 0, Math.PI * 2);
          ctx.ellipse(14, 0, 5, 3, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Mouth
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 4, 10, 0.1 * Math.PI, 0.9 * Math.PI);
          ctx.stroke();
          
          // Teeth
          ctx.fillStyle = '#FFF';
          ctx.fillRect(-5, 4, 4, 7);
          ctx.fillRect(1, 4, 4, 7);
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1;
          ctx.strokeRect(-5, 4, 4, 7);
          ctx.strokeRect(1, 4, 4, 7);
          
          // Pores
          ctx.fillStyle = '#CC9900';
          [[-12, -4], [-10, -8], [-14, -10], [12, -4], [10, -8], [14, -10]].forEach(([fx, fy]) => {
            ctx.beginPath();
            ctx.arc(fx, fy, 1.5, 0, Math.PI * 2);
            ctx.fill();
          });
          
          // Sponge holes
          ctx.fillStyle = '#DAA520';
          [[-12, -22], [10, -20], [-6, -2], [8, 0], [-14, 6]].forEach(([hx, hy]) => {
            ctx.beginPath();
            ctx.ellipse(hx, hy, 3, 2, Math.random(), 0, Math.PI * 2);
            ctx.fill();
          });
          
          // Arms
          ctx.fillStyle = '#FFE135';
          ctx.fillRect(-12, 28, 6, 10);
          ctx.fillRect(6, 28, 6, 10);
          
          // Shoes
          ctx.fillStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.ellipse(-9, 40, 8, 5, 0, 0, Math.PI * 2);
          ctx.ellipse(9, 40, 8, 5, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#FFF';
          ctx.fillRect(-14, 32, 10, 6);
          ctx.fillRect(4, 32, 10, 6);
          ctx.fillStyle = '#FF0000';
          ctx.fillRect(-14, 34, 10, 2);
          ctx.fillRect(4, 34, 10, 2);
          ctx.fillStyle = '#0000FF';
          ctx.fillRect(-14, 36, 10, 2);
          ctx.fillRect(4, 36, 10, 2);
          
          ctx.restore();
          
          // Damage numbers
          game.damageNumbers.forEach(d => {
            const sx = d.x - game.camera.x, sy = d.y - game.camera.y;
            ctx.globalAlpha = d.life / 40;
            ctx.font = d.crit ? 'bold 20px Arial' : 'bold 14px Arial';
            ctx.fillStyle = d.crit ? '#FF0' : '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText(d.damage, sx, sy);
          });
          ctx.globalAlpha = 1;
          
          ctx.restore(); // End screen shake transform
        };
        
        animationId = requestAnimationFrame(gameLoop);
        return () => { cancelAnimationFrame(animationId); };
      }, [gameState, showUpgrade, weapons, playerStats, xpToLevel, time, generateUpgrades, addWeaponFromChest, xp]);

      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

      // Quit game function
      const quitGame = () => {
        gameOverRef.current = true;
        setGameState('gameover');
        // Auto-submit score
        if (typeof showLeaderboardModal === 'function') {
          setTimeout(() => showLeaderboardModal('survivors', '$COCKPANTS Survivors', score), 500);
        }
      };

      // MENU - Enhanced
      if (gameState === 'menu') {
        return (
          <div className="flex flex-col items-center justify-center h-screen relative overflow-hidden" style={{ background: 'linear-gradient(135deg, #0a1628 0%, #1a3a5c 50%, #0d2040 100%)' }}>
            {/* Animated background particles */}
            <div className="absolute inset-0 overflow-hidden pointer-events-none">
              {Array.from({ length: 20 }).map((_, i) => (
                <div 
                  key={i}
                  className="absolute rounded-full opacity-20"
                  style={{
                    width: 4 + Math.random() * 8 + 'px',
                    height: 4 + Math.random() * 8 + 'px',
                    background: '#87CEEB',
                    left: Math.random() * 100 + '%',
                    top: Math.random() * 100 + '%',
                    animation: `pulse ${2 + Math.random() * 3}s ease-in-out infinite`,
                    animationDelay: Math.random() * 2 + 's'
                  }}
                />
              ))}
            </div>
            
            <div className="relative z-10 flex flex-col items-center">
              <div className="text-7xl font-black mb-1 tracking-tight" style={{ 
                color: '#FFD700', 
                textShadow: '4px 4px 0 #000, 0 0 40px rgba(255, 215, 0, 0.5)',
                letterSpacing: '-2px'
              }}>
                $COCKPANTS
              </div>
              <div className="text-4xl font-bold text-cyan-300 mb-6" style={{ textShadow: '0 0 20px rgba(100, 200, 255, 0.5)' }}>
                SURVIVORS
              </div>
              
              <div className="text-9xl mb-8 transform hover:scale-110 transition-transform" style={{ filter: 'drop-shadow(0 0 20px rgba(255, 215, 0, 0.4))' }}>
                ðŸ§½
              </div>
              
              <button 
                onClick={startGame} 
                className="px-12 py-5 text-2xl font-bold rounded-2xl transform hover:scale-105 transition-all relative overflow-hidden group"
                style={{ 
                  background: 'linear-gradient(145deg, #FFD700, #FFA500)', 
                  color: '#000',
                  boxShadow: '0 6px 0 #CC8400, 0 10px 30px rgba(255, 165, 0, 0.4)'
                }}
              >
                <span className="relative z-10">ðŸŽ® START GAME</span>
                <div className="absolute inset-0 bg-white opacity-0 group-hover:opacity-20 transition-opacity" />
              </button>
              
              <div className="mt-10 text-cyan-200 text-center space-y-2 p-6 rounded-xl" style={{ background: 'rgba(0, 20, 40, 0.6)', backdropFilter: 'blur(10px)' }}>
                <p className="text-lg">ðŸŽ¯ <span className="text-white font-bold">WASD</span> or <span className="text-white font-bold">Arrows</span> to move</p>
                <p className="text-lg">âš”ï¸ Auto-attack nearby enemies</p>
                <p className="text-lg">â­ Collect XP to level up & unlock upgrades!</p>
              </div>
            </div>
          </div>
        );
      }

      // GAME OVER - Enhanced
      if (gameState === 'gameover') {
        return (
          <div className="flex flex-col items-center justify-center h-screen relative overflow-hidden" style={{ background: 'linear-gradient(135deg, #1a0808 0%, #2d1515 50%, #1a0505 100%)' }}>
            {/* Animated red particles */}
            <div className="absolute inset-0 overflow-hidden pointer-events-none opacity-30">
              {Array.from({ length: 15 }).map((_, i) => (
                <div 
                  key={i}
                  className="absolute rounded-full"
                  style={{
                    width: 3 + Math.random() * 6 + 'px',
                    height: 3 + Math.random() * 6 + 'px',
                    background: '#FF4444',
                    left: Math.random() * 100 + '%',
                    top: Math.random() * 100 + '%',
                    animation: `pulse ${2 + Math.random() * 2}s ease-in-out infinite`
                  }}
                />
              ))}
            </div>

            <div className="relative z-10 flex flex-col items-center">
              <div className="text-6xl font-black mb-4" style={{ 
                color: '#FF4444', 
                textShadow: '4px 4px 0 #000, 0 0 30px rgba(255, 68, 68, 0.5)'
              }}>
                GAME OVER
              </div>
              <div className="text-8xl mb-8" style={{ filter: 'drop-shadow(0 0 20px rgba(255, 68, 68, 0.4))' }}>ðŸ’€</div>
              
              <div className="rounded-2xl p-8 mb-8 text-white space-y-3" style={{ 
                background: 'linear-gradient(145deg, rgba(0,0,0,0.7), rgba(30,10,10,0.8))',
                border: '2px solid rgba(255, 215, 0, 0.5)',
                boxShadow: '0 10px 40px rgba(0, 0, 0, 0.5)',
                minWidth: '280px'
              }}>
                <div className="flex justify-between gap-10 text-xl">
                  <span className="text-gray-400">Score</span>
                  <span className="text-yellow-400 font-bold" style={{ textShadow: '0 0 10px rgba(255, 215, 0, 0.5)' }}>{score.toLocaleString()}</span>
                </div>
                <div className="flex justify-between gap-10 text-xl">
                  <span className="text-gray-400">Level</span>
                  <span className="text-green-400 font-bold">{level}</span>
                </div>
                <div className="flex justify-between gap-10 text-xl">
                  <span className="text-gray-400">Time</span>
                  <span className="text-cyan-400 font-bold">{formatTime(time)}</span>
                </div>
                <div className="flex justify-between gap-10 text-xl">
                  <span className="text-gray-400">Kills</span>
                  <span className="text-red-400 font-bold">{kills}</span>
                </div>
                {weapons.length > 1 && (
                  <div className="pt-3 border-t border-gray-700">
                    <div className="text-gray-500 text-sm mb-2">Weapons Used:</div>
                    <div className="flex gap-2 justify-center">
                      {weapons.map((w, i) => (
                        <span key={i} className="text-2xl" title={w.name}>{w.emoji}</span>
                      ))}
                    </div>
                  </div>
                )}
              </div>
              
              <div className="flex gap-4">
                <button 
                  onClick={() => { if (typeof showLeaderboardModal === 'function') showLeaderboardModal('survivors', '$COCKPANTS Survivors', score); }}
                  className="px-8 py-4 text-xl font-bold rounded-xl transform hover:scale-105 transition-all"
                  style={{ 
                    background: 'linear-gradient(145deg, #4A90E2, #357ABD)', 
                    color: '#FFF',
                    boxShadow: '0 4px 0 #2868A0, 0 6px 20px rgba(74, 144, 226, 0.3)'
                  }}
                >
                  ðŸ† LEADERBOARD
                </button>
                <button 
                  onClick={startGame} 
                  className="px-8 py-4 text-xl font-bold rounded-xl transform hover:scale-105 transition-all"
                  style={{ 
                    background: 'linear-gradient(145deg, #FFD700, #FFA500)', 
                    color: '#000',
                    boxShadow: '0 4px 0 #CC8400, 0 6px 20px rgba(255, 165, 0, 0.3)'
                  }}
                >
                  ðŸ”„ TRY AGAIN
                </button>
              </div>
            </div>
          </div>
        );
      }

      // PLAYING
      return (
        <div className="flex flex-col items-center h-screen" style={{ background: '#000', padding: '10px' }}>
          {/* Mobile Joystick */}
          <div className={`mobile-joystick ${gameState === 'playing' ? 'visible' : ''}`}>
            <div className="joystick-base" id="joystickBase">
              <div className="joystick-stick" id="joystickStick"></div>
            </div>
          </div>
          
          {/* Boss Warning */}
          {bossWarning && (
            <div className="absolute top-1/2 left-1/2 z-50 boss-warning">
              <div className="bg-red-900/90 border-4 border-red-500 rounded-xl px-8 py-4 text-center shadow-2xl" style={{ boxShadow: '0 0 40px rgba(255, 0, 0, 0.8)' }}>
                <div className="text-4xl mb-2">âš ï¸</div>
                <div className="text-3xl font-bold text-yellow-400" style={{ textShadow: '0 0 20px rgba(255, 215, 0, 1)' }}>BOSS INCOMING!</div>
              </div>
            </div>
          )}
          
          {/* Combo Display */}
          {combo > 0 && (
            <div className="absolute top-20 left-1/2 transform -translate-x-1/2 z-40 combo-display">
              <div className="text-4xl font-black" style={{ 
                color: combo > 10 ? '#FF0000' : combo > 5 ? '#FFD700' : '#FFF',
                textShadow: '0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4)',
              }}>
                {combo}x COMBO!
              </div>
            </div>
          )}
          
          {/* Quit Button */}
          <button 
            onClick={quitGame}
            className="absolute top-4 right-4 z-30 px-4 py-2 text-sm font-bold rounded-lg"
            style={{ background: 'rgba(220, 38, 38, 0.9)', color: '#FFF', border: '2px solid #DC2626' }}
          >
            ðŸšª QUIT & SAVE
          </button>
          
          {/* UI Bar Above Game - Enhanced */}
          <div className="w-full max-w-4xl mb-2 flex justify-between items-center px-5 py-3 rounded-xl hud-panel">
            {/* Left Side - Score & Info */}
            <div className="flex items-center gap-5">
              <div>
                <div className="text-xl font-black tracking-wide" style={{ color: '#FFD700', textShadow: '0 0 10px rgba(255, 215, 0, 0.4)' }}>$COCKPANTS</div>
                <div className="text-white text-sm font-medium">Score: <span className="text-yellow-400 font-bold">{score.toLocaleString()}</span></div>
                <div className="text-white/80 text-xs flex items-center gap-2">
                  <span>â±ï¸ {formatTime(time)}</span>
                  <span className="text-gray-500">|</span>
                  <span>ðŸ’€ {kills}</span>
                  {combo > 0 && <>
                    <span className="text-gray-500">|</span>
                    <span className="text-orange-400 font-bold">ðŸ”¥ {combo}x</span>
                  </>}
                </div>
              </div>
              
              {/* HP Bar - Enhanced */}
              <div>
                <div className="flex items-center justify-between mb-1">
                  <span className="text-red-400 text-xs font-bold">â¤ï¸ HEALTH</span>
                  <span className="text-white text-xs">{Math.floor(playerStats.hp)}/{playerStats.maxHp}</span>
                </div>
                <div className="stat-bar w-44 h-5 bg-black/70 rounded-full border border-red-500/50 overflow-hidden relative">
                  <div className="h-full transition-all duration-200 rounded-full" style={{ 
                    width: `${(playerStats.hp / playerStats.maxHp) * 100}%`,
                    background: playerStats.hp / playerStats.maxHp > 0.5 
                      ? 'linear-gradient(90deg, #22c55e, #4ade80)' 
                      : playerStats.hp / playerStats.maxHp > 0.25 
                        ? 'linear-gradient(90deg, #eab308, #facc15)' 
                        : 'linear-gradient(90deg, #dc2626, #ef4444)',
                    boxShadow: playerStats.hp / playerStats.maxHp <= 0.25 ? '0 0 10px rgba(239, 68, 68, 0.5)' : 'none'
                  }} />
                </div>
                {playerStats.armor > 0 && (
                  <div className="text-xs text-blue-400 mt-0.5">ðŸ›¡ï¸ +{playerStats.armor} Armor</div>
                )}
              </div>
            </div>
            
            {/* Right Side - Level & Weapons */}
            <div className="flex items-center gap-5">
              {/* Level & XP - Enhanced */}
              <div className="text-right">
                <div className="text-green-400 font-bold text-lg" style={{ textShadow: '0 0 8px rgba(34, 197, 94, 0.4)' }}>
                  Level {level}
                </div>
                <div className="stat-bar w-36 h-4 bg-black/70 rounded-full border border-green-500/50 overflow-hidden relative">
                  <div className="h-full rounded-full transition-all duration-300" style={{ 
                    width: `${(xp / xpToLevel) * 100}%`,
                    background: 'linear-gradient(90deg, #22c55e, #86efac)'
                  }} />
                </div>
                <div className="text-xs text-green-300/80 mt-0.5">{xp} / {xpToLevel} XP</div>
              </div>
              
              {/* Weapons - Enhanced */}
              <div>
                <div className="text-xs text-gray-400 mb-1.5 text-center uppercase tracking-wider">Weapons</div>
                <div className="flex gap-1.5">
                  {weapons.map((w, i) => (
                    <div 
                      key={i} 
                      className="weapon-slot w-11 h-11 rounded-lg flex flex-col items-center justify-center text-lg relative"
                      style={{ 
                        background: 'linear-gradient(145deg, rgba(0,0,0,0.8), rgba(20,30,50,0.9))', 
                        border: `2px solid ${w.color}`,
                        boxShadow: `0 0 10px ${w.color}40`
                      }}
                    >
                      {w.emoji}
                      <span className="absolute -bottom-0.5 text-[9px] text-white/80 font-bold bg-black/60 px-1 rounded">
                        {w.level}
                      </span>
                    </div>
                  ))}
                  {/* Empty weapon slots */}
                  {Array.from({ length: Math.max(0, 6 - weapons.length) }).map((_, i) => (
                    <div 
                      key={`empty-${i}`}
                      className="w-11 h-11 rounded-lg flex items-center justify-center text-gray-600"
                      style={{ 
                        background: 'rgba(0,0,0,0.3)', 
                        border: '2px dashed rgba(100,100,100,0.3)'
                      }}
                    >
                      +
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
          
          {/* Game Canvas - Enhanced */}
          <canvas 
            ref={canvasRef} 
            width={GAME_WIDTH} 
            height={GAME_HEIGHT} 
            className="rounded-xl game-canvas" 
            style={{ 
              border: '3px solid rgba(255, 215, 0, 0.7)', 
              maxWidth: '100vw', 
              maxHeight: 'calc(100vh - 140px)',
              boxShadow: '0 0 30px rgba(0, 100, 200, 0.3), inset 0 0 50px rgba(0, 50, 100, 0.2)'
            }} 
          />
          
          {/* Upgrade Modal - Enhanced */}
          {showUpgrade && (
            <div className="absolute inset-0 bg-black/90 game-paused-overlay flex items-center justify-center z-20">
              <div className="upgrade-modal p-8 rounded-2xl relative" style={{ 
                background: 'linear-gradient(145deg, #1a2a4a, #0d1a2f)', 
                border: '3px solid #FFD700',
                boxShadow: '0 0 50px rgba(255, 215, 0, 0.3), inset 0 0 30px rgba(0, 100, 200, 0.2)'
              }}>
                {/* PAUSED indicator */}
                <div className="absolute -top-4 left-1/2 transform -translate-x-1/2 px-4 py-1 rounded-full text-sm font-bold" style={{ background: '#FFD700', color: '#000' }}>
                  â¸ï¸ GAME PAUSED
                </div>
                
                <div className="text-4xl font-bold text-center mb-2" style={{ 
                  color: '#FFD700', 
                  textShadow: '0 0 20px rgba(255, 215, 0, 0.5)',
                  animation: 'levelUpGlow 2s ease-in-out infinite'
                }}>
                  ðŸŽ‰ LEVEL {level}! ðŸŽ‰
                </div>
                <div className="text-cyan-300 text-center mb-6 text-lg">Choose your upgrade</div>
                
                {/* Queued level-ups indicator */}
                {levelUpQueueRef.current > 0 && (
                  <div className="text-center mb-4 text-yellow-400 text-sm animate-pulse">
                    +{levelUpQueueRef.current} more level-up{levelUpQueueRef.current > 1 ? 's' : ''} queued!
                  </div>
                )}
                
                <div className="flex gap-4">
                  {upgradeOptions.map((opt, i) => (
                    <button 
                      key={i} 
                      onClick={() => selectUpgrade(opt)} 
                      className="upgrade-card p-5 rounded-xl w-40 cursor-pointer"
                      style={{ 
                        background: 'linear-gradient(145deg, #152035, #0a1525)', 
                        border: '2px solid rgba(100, 200, 255, 0.4)',
                        boxShadow: '0 4px 15px rgba(0, 0, 0, 0.3)'
                      }}
                    >
                      <div className="text-4xl mb-3 transform transition-transform">{opt.emoji}</div>
                      <div className="text-white font-bold text-base mb-1">{opt.desc}</div>
                      <div className="text-cyan-400/70 text-xs">{opt.subdesc}</div>
                      {opt.stat === 'weapon' && (
                        <div className="mt-2 text-xs text-yellow-400 font-bold">âœ¨ NEW WEAPON!</div>
                      )}
                    </button>
                  ))}
                </div>
                
                <div className="text-center mt-4 text-gray-500 text-xs">
                  Click an upgrade to continue
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<CockpantsSurvivors />, document.getElementById('root'));
  </script>
</body>
</html>
