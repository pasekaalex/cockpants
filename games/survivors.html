<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>$COCKPANTS Survivors</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="../leaderboard.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @font-face {
      font-family: 'Krabby Patty';
      src: url('../Krabby Patty.ttf') format('truetype');
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { 
      background: #000; 
      overflow: hidden;
      font-family: 'Krabby Patty', Arial, sans-serif;
      touch-action: none;
      user-select: none;
    }
    #root { width: 100vw; height: 100vh; }
    
    .mobile-joystick {
      display: none;
      position: fixed;
      bottom: 100px;
      left: 20px;
      width: 120px;
      height: 120px;
      z-index: 1000;
    }
    
    .joystick-base {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.5);
      border: 3px solid rgba(255, 215, 0, 0.6);
      position: relative;
    }
    
    .joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 215, 0, 0.8);
      border: 2px solid #FFD700;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    
    @media (max-width: 768px) {
      .mobile-joystick.visible { display: block; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const GAME_WIDTH = 900;
    const GAME_HEIGHT = 650;
    const PLAYER_SIZE = 44;
    const ENEMY_SIZE = 36;
    const BASE_PLAYER_SPEED = 3.0;
    const ENEMY_SPEED_MULT = 0.6;

    const WEAPONS = {
      spatula: { damage: 25, cooldown: 600, speed: 9, color: '#FFD700', name: 'Krusty Spatula', emoji: 'üç≥', pierce: 1 },
      bubble: { damage: 15, cooldown: 250, speed: 7, color: '#87CEEB', name: 'Bubble Wand', emoji: 'ü´ß', pierce: 2 },
      clarinet: { damage: 50, cooldown: 1200, speed: 12, color: '#8B4513', name: 'Clarinet Blast', emoji: 'üéµ', pierce: 3 },
      jellyNet: { damage: 30, cooldown: 450, speed: 8, color: '#FF69B4', name: 'Jellyfish Net', emoji: 'ü™º', pierce: 1 },
      karate: { damage: 70, cooldown: 1500, speed: 14, color: '#FF4500', name: 'Karate Chop', emoji: 'ü•ã', pierce: 5 },
      pattyBlast: { damage: 40, cooldown: 750, speed: 10, color: '#CD853F', name: 'Krabby Patty', emoji: 'üçî', pierce: 2 },
    };

    const ENEMIES = {
      plankton: { hp: 15, speed: 1.8, xp: 3, color: '#228B22', name: 'Plankton', scale: 0.6 },
      krabs: { hp: 80, speed: 0.9, xp: 20, color: '#DC143C', name: 'Mr. Krabs', scale: 1.2 },
      squidward: { hp: 40, speed: 1.1, xp: 10, color: '#40E0D0', name: 'Squidward', scale: 1.0 },
      patrick: { hp: 120, speed: 0.6, xp: 25, color: '#FFB6C1', name: 'Patrick', scale: 1.3 },
      sandy: { hp: 60, speed: 1.4, xp: 15, color: '#DEB887', name: 'Sandy', scale: 1.0 },
      doodlebob: { hp: 200, speed: 0.8, xp: 50, color: '#FFFFFF', name: 'DoodleBob', scale: 1.4, boss: true },
    };

    const UPGRADE_TYPES = [
      { stat: 'damage', emoji: '‚öîÔ∏è', desc: '+15% Damage', subdesc: 'Hit harder!' },
      { stat: 'attackSpeed', emoji: 'üî•', desc: '+12% Attack Speed', subdesc: 'Fire faster!' },
      { stat: 'projectileSize', emoji: 'üí•', desc: '+15% Projectile Size', subdesc: 'Bigger hits!' },
      { stat: 'pierce', emoji: 'üó°Ô∏è', desc: '+1 Pierce', subdesc: 'Hit more enemies!' },
      { stat: 'speed', emoji: '‚ö°', desc: '+10% Move Speed', subdesc: 'Gotta go fast!' },
      { stat: 'maxHp', emoji: '‚ù§Ô∏è', desc: '+40 Max HP', subdesc: 'More tankiness!' },
      { stat: 'armor', emoji: 'üõ°Ô∏è', desc: '+3 Armor', subdesc: 'Take less damage!' },
      { stat: 'pickupRange', emoji: 'üß≤', desc: '+25% Pickup Range', subdesc: 'Vacuum XP!' },
    ];

    function CockpantsSurvivors() {
      const canvasRef = useRef(null);
      const [gameState, setGameState] = useState('menu');
      const [score, setScore] = useState(0);
      const [level, setLevel] = useState(1);
      const [xp, setXp] = useState(0);
      const [xpToLevel, setXpToLevel] = useState(15);
      const [time, setTime] = useState(0);
      const [kills, setKills] = useState(0);
      const [showUpgrade, setShowUpgrade] = useState(false);
      const [upgradeOptions, setUpgradeOptions] = useState([]);
      const [weapons, setWeapons] = useState([]);
      const [playerStats, setPlayerStats] = useState({ speedBonus: 1, maxHp: 250, hp: 250, pickupRange: 60, armor: 0 });
      const [screenShake, setScreenShake] = useState(0);
      const [combo, setCombo] = useState(0);
      const gameOverRef = useRef(false);
      const touchRef = useRef({ active: false, startX: 0, startY: 0, dx: 0, dy: 0 });

      const gameRef = useRef({
        player: { x: 0, y: 0, facing: 1 },
        enemies: [],
        projectiles: [],
        xpOrbs: [],
        chests: [],
        particles: [],
        damageNumbers: [],
        keys: {},
        lastShot: {},
        camera: { x: 0, y: 0 },
      });

      const generateUpgrades = useCallback(() => {
        const shuffled = [...UPGRADE_TYPES].sort(() => Math.random() - 0.5);
        setUpgradeOptions(shuffled.slice(0, 3));
      }, []);

      const selectUpgrade = (upgrade) => {
        if (upgrade.stat === 'damage') {
          setWeapons(prev => prev.map(w => ({ ...w, damageBonus: (w.damageBonus || 1) * 1.15 })));
        } else if (upgrade.stat === 'attackSpeed') {
          setWeapons(prev => prev.map(w => ({ ...w, cooldownBonus: (w.cooldownBonus || 1) * 0.88 })));
        } else if (upgrade.stat === 'projectileSize') {
          setWeapons(prev => prev.map(w => ({ ...w, sizeBonus: (w.sizeBonus || 1) * 1.15 })));
        } else if (upgrade.stat === 'pierce') {
          setWeapons(prev => prev.map(w => ({ ...w, pierce: (w.pierce || 1) + 1 })));
        } else if (upgrade.stat === 'speed') {
          setPlayerStats(prev => ({ ...prev, speedBonus: Math.min(prev.speedBonus * 1.1, 1.5) }));
        } else if (upgrade.stat === 'maxHp') {
          setPlayerStats(prev => ({ ...prev, maxHp: prev.maxHp + 40, hp: prev.hp + 40 }));
        } else if (upgrade.stat === 'armor') {
          setPlayerStats(prev => ({ ...prev, armor: prev.armor + 3 }));
        } else if (upgrade.stat === 'pickupRange') {
          setPlayerStats(prev => ({ ...prev, pickupRange: prev.pickupRange * 1.25 }));
        }
        setShowUpgrade(false);
      };

      const addWeaponFromChest = useCallback((weaponKey) => {
        const weapon = WEAPONS[weaponKey];
        if (!weapon) return;
        setWeapons(prev => {
          const existing = prev.find(w => w.name === weapon.name);
          if (existing) {
            return prev.map(w => w.name === weapon.name ? { ...w, level: w.level + 1, damageBonus: (w.damageBonus || 1) * 1.2 } : w);
          } else if (prev.length < 6) {
            return [...prev, { ...weapon, level: 1, damageBonus: 1, cooldownBonus: 1, sizeBonus: 1 }];
          }
          return prev.map(w => ({ ...w, damageBonus: (w.damageBonus || 1) * 1.1 }));
        });
      }, []);

      const startGame = () => {
        const currentKeys = gameRef.current.keys || {};
        gameOverRef.current = false;
        setScore(0);
        setLevel(1);
        setXp(0);
        setXpToLevel(15);
        setTime(0);
        setKills(0);
        setCombo(0);
        setShowUpgrade(false);
        setWeapons([{ ...WEAPONS.spatula, level: 1, damageBonus: 1, cooldownBonus: 1, sizeBonus: 1 }]);
        setPlayerStats({ speedBonus: 1, maxHp: 250, hp: 250, pickupRange: 60, armor: 0 });
        gameRef.current = {
          player: { x: 0, y: 0, facing: 1 },
          enemies: [],
          projectiles: [],
          xpOrbs: [],
          chests: [],
          particles: [],
          damageNumbers: [],
          keys: currentKeys,
          lastShot: {},
          camera: { x: 0, y: 0 },
        };
        touchRef.current = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
        setGameState('playing');
      };

      // Keyboard controls
      useEffect(() => {
        const handleKeyDown = (e) => { gameRef.current.keys[e.key.toLowerCase()] = true; };
        const handleKeyUp = (e) => { gameRef.current.keys[e.key.toLowerCase()] = false; };
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        return () => {
          window.removeEventListener('keydown', handleKeyDown);
          window.removeEventListener('keyup', handleKeyUp);
        };
      }, []);

      // Mobile joystick
      useEffect(() => {
        if (gameState !== 'playing') return;
        const joystick = document.getElementById('joystickBase');
        if (!joystick) return;

        const handleTouchStart = (e) => {
          e.preventDefault();
          const rect = joystick.getBoundingClientRect();
          touchRef.current.active = true;
          touchRef.current.startX = rect.left + rect.width / 2;
          touchRef.current.startY = rect.top + rect.height / 2;
        };
        const handleTouchMove = (e) => {
          if (!touchRef.current.active) return;
          e.preventDefault();
          const touch = e.touches[0];
          const dx = touch.clientX - touchRef.current.startX;
          const dy = touch.clientY - touchRef.current.startY;
          const dist = Math.hypot(dx, dy);
          const maxDist = 40;
          if (dist > 5) {
            touchRef.current.dx = (dx / Math.max(dist, maxDist)) * Math.min(dist, maxDist) / maxDist;
            touchRef.current.dy = (dy / Math.max(dist, maxDist)) * Math.min(dist, maxDist) / maxDist;
            const stick = document.getElementById('joystickStick');
            if (stick) {
              stick.style.transform = `translate(calc(-50% + ${touchRef.current.dx * 30}px), calc(-50% + ${touchRef.current.dy * 30}px))`;
            }
          }
        };
        const handleTouchEnd = () => {
          touchRef.current.active = false;
          touchRef.current.dx = 0;
          touchRef.current.dy = 0;
          const stick = document.getElementById('joystickStick');
          if (stick) stick.style.transform = 'translate(-50%, -50%)';
        };

        joystick.addEventListener('touchstart', handleTouchStart, { passive: false });
        window.addEventListener('touchmove', handleTouchMove, { passive: false });
        window.addEventListener('touchend', handleTouchEnd);
        return () => {
          joystick.removeEventListener('touchstart', handleTouchStart);
          window.removeEventListener('touchmove', handleTouchMove);
          window.removeEventListener('touchend', handleTouchEnd);
        };
      }, [gameState]);

      // Show leaderboard on game over
      useEffect(() => {
        if (gameState === 'gameover' && typeof showLeaderboardModal === 'function') {
          setTimeout(() => showLeaderboardModal('survivors', '$COCKPANTS Survivors', score), 500);
        }
      }, [gameState, score]);

      // Main game loop
      useEffect(() => {
        if (gameState !== 'playing' || showUpgrade) return;
        gameOverRef.current = false;

        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let animationId;
        let lastFrameTime = performance.now();
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS; // ~16.67ms per frame
        let spawnTimer = 0;
        let timeTimer = 0;
        let accumulatedTime = 0;

        const spawnEnemy = () => {
          const game = gameRef.current;
          const side = Math.floor(Math.random() * 4);
          let x, y;
          const offset = 150;
          if (side === 0) { x = game.player.x + (Math.random() - 0.5) * GAME_WIDTH; y = game.player.y - GAME_HEIGHT/2 - offset; }
          else if (side === 1) { x = game.player.x + GAME_WIDTH/2 + offset; y = game.player.y + (Math.random() - 0.5) * GAME_HEIGHT; }
          else if (side === 2) { x = game.player.x + (Math.random() - 0.5) * GAME_WIDTH; y = game.player.y + GAME_HEIGHT/2 + offset; }
          else { x = game.player.x - GAME_WIDTH/2 - offset; y = game.player.y + (Math.random() - 0.5) * GAME_HEIGHT; }

          let pool = ['plankton'];
          if (time > 15) pool.push('squidward');
          if (time > 30) pool.push('krabs');
          if (time > 45) pool.push('sandy');
          if (time > 60) pool.push('patrick');
          
          const typeKey = pool[Math.floor(Math.random() * pool.length)];
          const template = ENEMIES[typeKey];
          const isElite = Math.random() < 0.05;
          const mult = isElite ? 3 : 1;
          
          game.enemies.push({
            ...template,
            x, y,
            hp: template.hp * mult,
            maxHp: template.hp * mult,
            type: typeKey,
            isElite,
            hit: 0,
          });
        };

        const shootProjectiles = () => {
          const game = gameRef.current;
          const now = Date.now();
          
          weapons.forEach(weapon => {
            const cooldown = weapon.cooldown * (weapon.cooldownBonus || 1);
            if (!game.lastShot[weapon.name] || now - game.lastShot[weapon.name] > cooldown) {
              let nearest = null;
              let nearestDist = 500;
              game.enemies.forEach(e => {
                const dist = Math.hypot(e.x - game.player.x, e.y - game.player.y);
                if (dist < nearestDist) { nearestDist = dist; nearest = e; }
              });
              
              if (nearest) {
                game.lastShot[weapon.name] = now;
                const angle = Math.atan2(nearest.y - game.player.y, nearest.x - game.player.x);
                const shots = weapon.level >= 5 ? 3 : weapon.level >= 3 ? 2 : 1;
                
                for (let i = 0; i < shots; i++) {
                  const shotAngle = angle + (i - (shots - 1) / 2) * 0.15;
                  game.projectiles.push({
                    x: game.player.x, y: game.player.y,
                    vx: Math.cos(shotAngle) * weapon.speed,
                    vy: Math.sin(shotAngle) * weapon.speed,
                    damage: weapon.damage * (weapon.damageBonus || 1),
                    color: weapon.color,
                    life: 120,
                    pierce: weapon.pierce + Math.floor(weapon.level / 2),
                    size: (6 + weapon.level) * (weapon.sizeBonus || 1),
                    hit: [],
                  });
                }
              }
            }
          });
        };

        const gameLoop = (currentTime) => {
          if (gameOverRef.current) return;
          
          // Fixed timestep - always use 1.0 delta per frame
          // This ensures game speed NEVER changes
          const delta = 1.0;
          
          // Only update lastFrameTime for reference, but don't use it for calculations
          lastFrameTime = currentTime || performance.now();
          
          const game = gameRef.current;
          const keys = game.keys;
          
          // Player movement
          let dx = 0, dy = 0;
          if (keys['w'] || keys['arrowup']) dy -= 1;
          if (keys['s'] || keys['arrowdown']) dy += 1;
          if (keys['a'] || keys['arrowleft']) dx -= 1;
          if (keys['d'] || keys['arrowright']) dx += 1;
          
          if (touchRef.current.active) {
            dx = touchRef.current.dx;
            dy = touchRef.current.dy;
          }
          
          if (dx !== 0 || dy !== 0) {
            const len = Math.hypot(dx, dy);
            const speed = BASE_PLAYER_SPEED * (playerStats.speedBonus || 1);
            game.player.x += (dx / len) * speed * delta;
            game.player.y += (dy / len) * speed * delta;
            game.player.facing = dx !== 0 ? Math.sign(dx) : game.player.facing;
          }
          
          game.camera.x = game.player.x - GAME_WIDTH / 2;
          game.camera.y = game.player.y - GAME_HEIGHT / 2;
          
          // Spawn enemies
          spawnTimer += delta;
          const spawnRate = Math.max(25, 45 - time * 0.15); // Reasonable spawn rate
          if (spawnTimer > spawnRate) {
            spawnTimer = 0;
            const count = Math.min(1 + Math.floor(time / 30), 3);
            for (let i = 0; i < count; i++) spawnEnemy();
          }
          
          // Time - count frames, 60 frames = 1 second at 60fps
          timeTimer += 1; // Count frames, not delta
          if (timeTimer >= 60) { 
            timeTimer = 0; 
            setTime(t => t + 1); 
          }
          
          // Shoot
          shootProjectiles();
          
          // Update projectiles
          game.projectiles = game.projectiles.filter(p => {
            p.x += p.vx * delta;
            p.y += p.vy * delta;
            p.life -= delta;
            return p.life > 0 && p.pierce > 0;
          });
          
          // Update enemies
          game.enemies.forEach(e => {
            const angle = Math.atan2(game.player.y - e.y, game.player.x - e.x);
            e.x += Math.cos(angle) * e.speed * ENEMY_SPEED_MULT * delta;
            e.y += Math.sin(angle) * e.speed * ENEMY_SPEED_MULT * delta;
            if (e.hit > 0) e.hit -= delta;
          });
          
          // Projectile-enemy collision
          game.projectiles.forEach(p => {
            game.enemies.forEach(e => {
              if (p.pierce <= 0 || p.hit.includes(e)) return;
              const dist = Math.hypot(p.x - e.x, p.y - e.y);
              if (dist < ENEMY_SIZE * (e.scale || 1)) {
                const crit = Math.random() < 0.15;
                const dmg = crit ? p.damage * 2 : p.damage;
                e.hp -= dmg;
                e.hit = 8;
                p.pierce--;
                p.hit.push(e);
                
                game.damageNumbers.push({ x: e.x, y: e.y - 20, damage: Math.floor(dmg), life: 40, vy: -2 * delta, crit });
                
                if (e.hp <= 0) {
                  // Drop XP
                  const orbCount = Math.ceil(e.xp / 5);
                  for (let i = 0; i < orbCount; i++) {
                    game.xpOrbs.push({ x: e.x + (Math.random() - 0.5) * 30, y: e.y + (Math.random() - 0.5) * 30, xp: Math.ceil(e.xp / orbCount) });
                  }
                  // Elite drops chest
                  if (e.isElite) {
                    const weaponKeys = Object.keys(WEAPONS);
                    game.chests.push({ x: e.x, y: e.y, weapon: weaponKeys[Math.floor(Math.random() * weaponKeys.length)] });
                  }
                  setKills(k => k + 1);
                  setScore(s => s + e.xp * 10);
                }
              }
            });
          });
          game.enemies = game.enemies.filter(e => e.hp > 0);
          
          // Player-enemy collision
          game.enemies.forEach(e => {
            if (gameOverRef.current) return;
            const dist = Math.hypot(game.player.x - e.x, game.player.y - e.y);
            if (dist < (PLAYER_SIZE + ENEMY_SIZE * (e.scale || 1)) / 2) {
              const dmg = Math.max(0.5, 1 - playerStats.armor * 0.05) * delta;
              setPlayerStats(prev => {
                const newHp = prev.hp - dmg;
                if (newHp <= 0 && !gameOverRef.current) {
                  gameOverRef.current = true;
                  setGameState('gameover');
                  return { ...prev, hp: 0 };
                }
                return { ...prev, hp: Math.max(0, newHp) };
              });
            }
          });
          
          // Collect XP orbs
          game.xpOrbs = game.xpOrbs.filter(orb => {
            const dist = Math.hypot(game.player.x - orb.x, game.player.y - orb.y);
            if (dist < playerStats.pickupRange) {
              const angle = Math.atan2(game.player.y - orb.y, game.player.x - orb.x);
              orb.x += Math.cos(angle) * 8 * delta;
              orb.y += Math.sin(angle) * 8 * delta;
            }
            if (dist < 25) {
              setXp(prev => {
                const newXp = prev + orb.xp;
                if (newXp >= xpToLevel) {
                  setLevel(l => l + 1);
                  setXpToLevel(x => Math.floor(x * 1.25)); // Slower XP growth
                  setShowUpgrade(true);
                  generateUpgrades();
                  return 0;
                }
                return newXp;
              });
              return false;
            }
            return true;
          });
          
          // Collect chests
          game.chests = game.chests.filter(chest => {
            const dist = Math.hypot(game.player.x - chest.x, game.player.y - chest.y);
            if (dist < 40) {
              addWeaponFromChest(chest.weapon);
              setScore(s => s + 500);
              return false;
            }
            return true;
          });
          
          // Update damage numbers
          game.damageNumbers = game.damageNumbers.filter(d => {
            d.y += d.vy * delta;
            d.life -= delta;
            return d.life > 0;
          });
          
          // RENDER
          ctx.fillStyle = '#0a1628';
          ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
          
          // Grid
          ctx.strokeStyle = 'rgba(0, 191, 255, 0.08)';
          ctx.lineWidth = 1;
          const gridSize = 60;
          for (let x = -game.camera.x % gridSize; x < GAME_WIDTH; x += gridSize) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, GAME_HEIGHT); ctx.stroke();
          }
          for (let y = -game.camera.y % gridSize; y < GAME_HEIGHT; y += gridSize) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(GAME_WIDTH, y); ctx.stroke();
          }
          
          // XP orbs (pineapples)
          game.xpOrbs.forEach(orb => {
            const sx = orb.x - game.camera.x, sy = orb.y - game.camera.y;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(sx, sy, 6, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#228B22';
            ctx.fillRect(sx - 2, sy - 12, 4, 5);
          });
          
          // Chests
          game.chests.forEach(chest => {
            const sx = chest.x - game.camera.x, sy = chest.y - game.camera.y;
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(sx - 12, sy - 8, 24, 16);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(sx, sy, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(WEAPONS[chest.weapon]?.emoji || 'üì¶', sx, sy - 15);
          });
          
          // Draw Enemies with Art
          const drawEnemy = (ctx, e, sx, sy) => {
            const size = ENEMY_SIZE * (e.scale || 1);
            const hitFlash = e.hit > 0;
            
            ctx.save();
            ctx.translate(sx, sy);
            if (hitFlash) ctx.filter = 'brightness(2)';
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, size/2, size/2, size/4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            switch(e.type) {
              case 'plankton':
                // Green plankton body
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.ellipse(0, 0, size/3, size/2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Red eye
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(0, -size/6, size/4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(0, -size/6, size/8, 0, Math.PI * 2);
                ctx.fill();
                // Antennae
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-3, -size/2);
                ctx.lineTo(-5, -size/2 - 8);
                ctx.moveTo(3, -size/2);
                ctx.lineTo(5, -size/2 - 8);
                ctx.stroke();
                break;
                
              case 'krabs':
                // Red crab body
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.ellipse(0, 0, size/2, size/2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                // Claws
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.ellipse(-size/2 - 8, 0, 10, 7, -0.3, 0, Math.PI * 2);
                ctx.ellipse(size/2 + 8, 0, 10, 7, 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#FFFF00';
                ctx.beginPath();
                ctx.arc(-10, -size/2 - 8, 5, 0, Math.PI * 2);
                ctx.arc(10, -size/2 - 8, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-10, -size/2 - 8, 2, 0, Math.PI * 2);
                ctx.arc(10, -size/2 - 8, 2, 0, Math.PI * 2);
                ctx.fill();
                break;
                
              case 'squidward':
                // Teal squidward head
                ctx.fillStyle = '#40E0D0';
                ctx.beginPath();
                ctx.ellipse(0, -size/4, size/3, size/2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Body
                ctx.fillStyle = '#2F9F9F';
                ctx.beginPath();
                ctx.ellipse(0, size/6, size/5, size/3, 0, 0, Math.PI * 2);
                ctx.fill();
                // Nose
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(-12, -size/2, 8, 6);
                ctx.fillRect(4, -size/2, 8, 6);
                ctx.fillStyle = '#000';
                ctx.fillRect(-10, -size/2 + 2, 4, 4);
                ctx.fillRect(6, -size/2 + 2, 4, 4);
                // Mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, size/4, 6, 1.1 * Math.PI, 1.9 * Math.PI);
                ctx.stroke();
                break;
                
              case 'patrick':
                // Pink starfish
                ctx.fillStyle = '#FFB6C1';
                const points = 5;
                ctx.beginPath();
                for (let i = 0; i < points * 2; i++) {
                  const radius = i % 2 === 0 ? size/1.8 : size/3.5;
                  const angle = (i * Math.PI / points) - Math.PI / 2;
                  const px = Math.cos(angle) * radius;
                  const py = Math.sin(angle) * radius;
                  if (i === 0) ctx.moveTo(px, py);
                  else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                // Belly
                ctx.fillStyle = '#32CD32';
                ctx.beginPath();
                ctx.ellipse(0, size/4, size/3, size/5, 0, 0, Math.PI);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(-6, -size/6, 5, 0, Math.PI * 2);
                ctx.arc(6, -size/6, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-6, -size/6, 2, 0, Math.PI * 2);
                ctx.arc(6, -size/6, 2, 0, Math.PI * 2);
                ctx.fill();
                // Mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, size/8, 8, 0, Math.PI);
                ctx.stroke();
                break;
                
              case 'sandy':
                // Tan squirrel
                ctx.fillStyle = '#DEB887';
                ctx.beginPath();
                ctx.arc(0, 0, size/2.5, 0, Math.PI * 2);
                ctx.fill();
                // Goggles
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                ctx.stroke();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-5, -3, 3, 0, Math.PI * 2);
                ctx.arc(5, -3, 3, 0, Math.PI * 2);
                ctx.fill();
                // Cheeks
                ctx.fillStyle = '#FF9999';
                ctx.beginPath();
                ctx.arc(-10, 3, 4, 0, Math.PI * 2);
                ctx.arc(10, 3, 4, 0, Math.PI * 2);
                ctx.fill();
                break;
                
              default:
                // Generic enemy
                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.filter = 'none';
            ctx.restore();
            
            // HP bar
            if (e.type !== 'plankton') {
              const barW = size * 1.2;
              ctx.fillStyle = 'rgba(0,0,0,0.7)';
              ctx.fillRect(sx - barW/2, sy - size/2 - 12, barW, 6);
              ctx.fillStyle = e.hp / e.maxHp > 0.5 ? '#0F0' : e.hp / e.maxHp > 0.25 ? '#FF0' : '#F00';
              ctx.fillRect(sx - barW/2 + 1, sy - size/2 - 11, (barW - 2) * (e.hp / e.maxHp), 4);
            }
            
            // Elite crown
            if (e.isElite) {
              ctx.font = '16px Arial';
              ctx.textAlign = 'center';
              ctx.fillText('üëë', sx, sy - size/2 - 18);
            }
          };
          
          game.enemies.forEach(e => {
            const sx = e.x - game.camera.x, sy = e.y - game.camera.y;
            if (sx > -100 && sx < GAME_WIDTH + 100 && sy > -100 && sy < GAME_HEIGHT + 100) {
              if (e.isElite) {
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 20;
              }
              drawEnemy(ctx, e, sx, sy);
              ctx.shadowBlur = 0;
            }
          });
          
          // Projectiles
          game.projectiles.forEach(p => {
            const sx = p.x - game.camera.x, sy = p.y - game.camera.y;
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 10;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(sx, sy, p.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          });
          
          // Player (SpongeBob)
          const px = GAME_WIDTH / 2, py = GAME_HEIGHT / 2;
          ctx.fillStyle = '#FFD700';
          ctx.fillRect(px - 18, py - 25, 36, 45);
          ctx.fillStyle = '#FFF';
          ctx.beginPath();
          ctx.arc(px - 7, py - 10, 8, 0, Math.PI * 2);
          ctx.arc(px + 7, py - 10, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#00BFFF';
          ctx.beginPath();
          ctx.arc(px - 7, py - 10, 4, 0, Math.PI * 2);
          ctx.arc(px + 7, py - 10, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(px - 18, py + 10, 36, 12);
          
          // Damage numbers
          game.damageNumbers.forEach(d => {
            const sx = d.x - game.camera.x, sy = d.y - game.camera.y;
            ctx.globalAlpha = d.life / 40;
            ctx.font = d.crit ? 'bold 20px Arial' : 'bold 14px Arial';
            ctx.fillStyle = d.crit ? '#FF0' : '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText(d.damage, sx, sy);
          });
          ctx.globalAlpha = 1;
          
          if (!gameOverRef.current) {
            animationId = requestAnimationFrame(gameLoop);
          }
        };
        
        animationId = requestAnimationFrame(gameLoop);
        return () => { cancelAnimationFrame(animationId); };
      }, [gameState, showUpgrade, weapons, playerStats, xpToLevel, time, generateUpgrades, addWeaponFromChest]);

      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

      // MENU
      if (gameState === 'menu') {
        return (
          <div className="flex flex-col items-center justify-center h-screen" style={{ background: 'linear-gradient(180deg, #0a1628 0%, #1a3a5c 100%)' }}>
            <div className="text-6xl font-black mb-2" style={{ color: '#FFD700', textShadow: '3px 3px 0 #000' }}>$COCKPANTS</div>
            <div className="text-3xl text-cyan-300 mb-8">SURVIVORS</div>
            <div className="text-8xl mb-8">üßΩ</div>
            <button onClick={startGame} className="px-10 py-4 text-2xl font-bold rounded-xl" style={{ background: 'linear-gradient(180deg, #FFD700, #FFA500)', color: '#000' }}>
              üéÆ START GAME
            </button>
            <div className="mt-8 text-cyan-200 text-center">
              <p>WASD / Arrows to move</p>
              <p>Auto-attack enemies</p>
              <p>Collect XP to level up!</p>
            </div>
          </div>
        );
      }

      // GAME OVER
      if (gameState === 'gameover') {
        return (
          <div className="flex flex-col items-center justify-center h-screen" style={{ background: 'linear-gradient(180deg, #1a0a0a, #2d1515)' }}>
            <div className="text-5xl font-black mb-4" style={{ color: '#FF4444' }}>GAME OVER</div>
            <div className="text-7xl mb-6">üíÄ</div>
            <div className="bg-black/50 rounded-xl p-6 mb-6 text-white">
              <div className="flex justify-between gap-8 text-lg">
                <span>Score:</span><span className="text-yellow-400 font-bold">{score.toLocaleString()}</span>
              </div>
              <div className="flex justify-between gap-8 text-lg">
                <span>Level:</span><span className="text-green-400 font-bold">{level}</span>
              </div>
              <div className="flex justify-between gap-8 text-lg">
                <span>Time:</span><span className="text-cyan-400 font-bold">{formatTime(time)}</span>
              </div>
              <div className="flex justify-between gap-8 text-lg">
                <span>Kills:</span><span className="text-red-400 font-bold">{kills}</span>
              </div>
            </div>
            <div className="flex gap-4">
              <button onClick={() => { if (typeof showLeaderboardModal === 'function') showLeaderboardModal('survivors', '$COCKPANTS Survivors', score); }}
                className="px-8 py-3 text-xl font-bold rounded-xl" style={{ background: '#4A90E2', color: '#FFF' }}>
                üèÜ LEADERBOARD
              </button>
              <button onClick={startGame} className="px-8 py-3 text-xl font-bold rounded-xl" style={{ background: 'linear-gradient(180deg, #FFD700, #FFA500)', color: '#000' }}>
                üîÑ TRY AGAIN
              </button>
            </div>
          </div>
        );
      }

      // PLAYING
      return (
        <div className="flex flex-col items-center h-screen" style={{ background: '#000', padding: '10px' }}>
          {/* Mobile Joystick */}
          <div className={`mobile-joystick ${gameState === 'playing' ? 'visible' : ''}`}>
            <div className="joystick-base" id="joystickBase">
              <div className="joystick-stick" id="joystickStick"></div>
            </div>
          </div>
          
          {/* UI Bar Above Game */}
          <div className="w-full max-w-4xl mb-2 flex justify-between items-center px-4 py-2 rounded-lg" style={{ background: 'rgba(0, 0, 0, 0.8)', border: '2px solid #FFD700' }}>
            {/* Left Side - Score & Info */}
            <div className="flex items-center gap-4">
              <div>
                <div className="text-lg font-bold" style={{ color: '#FFD700' }}>$COCKPANTS</div>
                <div className="text-white text-sm">Score: <span className="text-yellow-400">{score.toLocaleString()}</span></div>
                <div className="text-white/70 text-xs">‚è±Ô∏è {formatTime(time)} | üíÄ {kills}</div>
              </div>
              
              {/* HP Bar */}
              <div>
                <div className="text-red-400 text-xs font-bold mb-1">‚ù§Ô∏è {Math.floor(playerStats.hp)}/{playerStats.maxHp}</div>
                <div className="w-40 h-4 bg-black/70 rounded-full border border-red-500/50 overflow-hidden">
                  <div className="h-full transition-all" style={{ 
                    width: `${(playerStats.hp / playerStats.maxHp) * 100}%`,
                    background: playerStats.hp / playerStats.maxHp > 0.5 ? '#22c55e' : playerStats.hp / playerStats.maxHp > 0.25 ? '#eab308' : '#dc2626'
                  }} />
                </div>
              </div>
            </div>
            
            {/* Right Side - Level & Weapons */}
            <div className="flex items-center gap-4">
              {/* Level & XP */}
              <div className="text-right">
                <div className="text-green-400 font-bold">Level {level}</div>
                <div className="w-32 h-3 bg-black/70 rounded-full border border-green-500/50 overflow-hidden">
                  <div className="h-full bg-green-500" style={{ width: `${(xp / xpToLevel) * 100}%` }} />
                </div>
                <div className="text-xs text-green-300/70">{xp}/{xpToLevel} XP</div>
              </div>
              
              {/* Weapons */}
              <div>
                <div className="text-xs text-gray-400 mb-1 text-center">WEAPONS</div>
                <div className="flex gap-1">
                  {weapons.map((w, i) => (
                    <div key={i} className="w-10 h-10 rounded-lg flex flex-col items-center justify-center text-lg" style={{ background: 'rgba(0,0,0,0.7)', border: `2px solid ${w.color}` }}>
                      {w.emoji}
                      <span className="text-[8px] text-white/70">Lv.{w.level}</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
          
          {/* Game Canvas */}
          <canvas ref={canvasRef} width={GAME_WIDTH} height={GAME_HEIGHT} className="rounded-lg" style={{ border: '3px solid #FFD700', maxWidth: '100vw', maxHeight: 'calc(100vh - 120px)' }} />
          
          {/* Upgrade Modal */}
          {showUpgrade && (
            <div className="absolute inset-0 bg-black/85 flex items-center justify-center z-20">
              <div className="p-6 rounded-xl" style={{ background: '#1a2a3a', border: '2px solid #FFD700' }}>
                <div className="text-3xl font-bold text-center mb-2" style={{ color: '#FFD700' }}>üéâ LEVEL UP! üéâ</div>
                <div className="text-cyan-300/70 text-center mb-4">Choose an upgrade</div>
                <div className="flex gap-3">
                  {upgradeOptions.map((opt, i) => (
                    <button key={i} onClick={() => selectUpgrade(opt)} className="p-4 rounded-xl border-2 hover:border-yellow-400 w-36" style={{ background: '#0d1a2a', borderColor: 'rgba(100, 200, 255, 0.3)' }}>
                      <div className="text-3xl mb-2">{opt.emoji}</div>
                      <div className="text-white font-bold text-sm">{opt.desc}</div>
                      <div className="text-cyan-300/60 text-xs">{opt.subdesc}</div>
                    </button>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<CockpantsSurvivors />, document.getElementById('root'));
  </script>
</body>
</html>
