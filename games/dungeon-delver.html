<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bikini Bottom Dungeon Delver | $COCKPANTS Games üó°Ô∏è</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="../leaderboard.js"></script>
  <script src="../sounds.js"></script>
  <style>
    @font-face {
      font-family: 'Krabby Patty';
      src: url('../Krabby Patty.ttf') format('truetype');
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
    }
    
    body {
      font-family: 'Krabby Patty', Arial, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      color: #fff;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
    }
    
    .game-container {
      display: grid;
      grid-template-columns: 300px 1fr 300px;
      grid-template-rows: 80px 1fr;
      height: 100vh;
      gap: 10px;
      padding: 10px;
    }
    
    .header {
      grid-column: 1 / -1;
      background: rgba(0,0,0,0.6);
      border: 2px solid #4a90e2;
      border-radius: 10px;
      padding: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 0 20px rgba(74, 144, 226, 0.3);
    }
    
    .header h1 {
      font-size: 32px;
      background: linear-gradient(135deg, #4a90e2, #7b68ee, #ff6b6b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
    }
    
    .header-buttons {
      display: flex;
      gap: 10px;
    }
    
    .btn {
      padding: 10px 20px;
      background: linear-gradient(135deg, #4a90e2, #7b68ee);
      border: 2px solid #fff;
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Krabby Patty', Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(74, 144, 226, 0.5);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .sidebar {
      background: rgba(0,0,0,0.7);
      border: 2px solid #4a90e2;
      border-radius: 10px;
      padding: 15px;
      overflow-y: auto;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
    }
    
    .sidebar h2 {
      font-size: 20px;
      margin-bottom: 15px;
      color: #4a90e2;
      text-align: center;
      border-bottom: 2px solid #4a90e2;
      padding-bottom: 10px;
    }
    
    .stat-item {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      margin: 5px 0;
      background: rgba(74, 144, 226, 0.1);
      border-radius: 5px;
      border-left: 3px solid #4a90e2;
    }
    
    .stat-label {
      color: #aaa;
      font-size: 14px;
    }
    
    .stat-value {
      color: #fff;
      font-weight: bold;
      font-size: 16px;
    }
    
    .stat-bar {
      width: 100%;
      height: 20px;
      background: rgba(0,0,0,0.5);
      border-radius: 10px;
      overflow: hidden;
      margin: 5px 0;
      border: 1px solid #4a90e2;
    }
    
    .stat-bar-fill {
      height: 100%;
      transition: width 0.3s;
      border-radius: 10px;
    }
    
    .hp-bar { background: linear-gradient(90deg, #ff4444, #ff6666); }
    .mp-bar { background: linear-gradient(90deg, #4444ff, #6666ff); }
    .xp-bar { background: linear-gradient(90deg, #44ff44, #66ff66); }
    
    .main-area {
      background: rgba(0,0,0,0.8);
      border: 2px solid #4a90e2;
      border-radius: 10px;
      padding: 20px;
      overflow-y: auto;
      position: relative;
      box-shadow: inset 0 0 30px rgba(0,0,0,0.5);
    }
    
    .dungeon-grid {
      display: grid;
      gap: 2px;
      margin: 0 auto;
      max-width: 800px;
    }
    
    .cell {
      width: 40px;
      height: 40px;
      background: #2a2a3e;
      border: 1px solid #1a1a2e;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.3s;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    
    .cell::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(255,255,255,0.1), transparent);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .cell:hover::before {
      opacity: 1;
    }
    
    .cell.wall {
      background: #1a1a1a;
      border-color: #000;
      background-image: repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(0,0,0,0.3) 2px, rgba(0,0,0,0.3) 4px);
    }
    
    .cell.floor {
      background: #3a3a4e;
      background-image: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.05), transparent 50%);
    }
    
    .cell.player {
      background: linear-gradient(135deg, #4a90e2, #7b68ee);
      box-shadow: 0 0 20px #4a90e2, 0 0 40px rgba(74, 144, 226, 0.5);
      border-color: #fff;
      animation: pulse 1s infinite, playerGlow 2s ease-in-out infinite;
      z-index: 10;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    @keyframes playerGlow {
      0%, 100% { box-shadow: 0 0 20px #4a90e2, 0 0 40px rgba(74, 144, 226, 0.5); }
      50% { box-shadow: 0 0 30px #4a90e2, 0 0 60px rgba(74, 144, 226, 0.8); }
    }
    
    .cell.enemy {
      background: linear-gradient(135deg, #ff4444, #cc0000);
      box-shadow: 0 0 15px #ff4444, 0 0 30px rgba(255, 68, 68, 0.5);
      border-color: #fff;
      animation: enemyPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes enemyPulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 15px #ff4444, 0 0 30px rgba(255, 68, 68, 0.5); }
      50% { transform: scale(1.05); box-shadow: 0 0 20px #ff4444, 0 0 40px rgba(255, 68, 68, 0.7); }
    }
    
    .cell.item {
      background: linear-gradient(135deg, #ffaa00, #ff8800);
      box-shadow: 0 0 15px #ffaa00, 0 0 30px rgba(255, 170, 0, 0.5);
      border-color: #fff;
      animation: itemFloat 2s ease-in-out infinite;
    }
    
    @keyframes itemFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }
    
    .cell.stairs {
      background: linear-gradient(135deg, #7b68ee, #5a4fcf);
      box-shadow: 0 0 20px #7b68ee, 0 0 40px rgba(123, 104, 238, 0.5);
      border-color: #fff;
      animation: stairsGlow 3s ease-in-out infinite;
    }
    
    @keyframes stairsGlow {
      0%, 100% { box-shadow: 0 0 20px #7b68ee, 0 0 40px rgba(123, 104, 238, 0.5); }
      50% { box-shadow: 0 0 30px #7b68ee, 0 0 60px rgba(123, 104, 238, 0.8); }
    }
    
    .particle {
      position: fixed;
      pointer-events: none;
      font-size: 20px;
      z-index: 2000;
      animation: particleFloat 1s ease-out forwards;
      text-shadow: 0 0 10px currentColor;
    }
    
    @keyframes particleFloat {
      0% { opacity: 1; transform: translateY(0) scale(1) rotate(0deg); }
      100% { opacity: 0; transform: translateY(-60px) scale(1.5) rotate(360deg); }
    }
    
    .main-area {
      position: relative;
    }
    
    .cell.visible {
      opacity: 1;
    }
    
    .cell.hidden {
      opacity: 0.2;
    }
    
    .combat-log {
      background: rgba(0,0,0,0.7);
      border: 2px solid #4a90e2;
      border-radius: 10px;
      padding: 15px;
      max-height: 200px;
      overflow-y: auto;
      margin-top: 15px;
      font-size: 14px;
      line-height: 1.6;
    }
    
    .log-entry {
      margin: 5px 0;
      padding: 5px;
      border-radius: 3px;
    }
    
    .log-entry.damage { background: rgba(255,68,68,0.2); }
    .log-entry.heal { background: rgba(68,255,68,0.2); }
    .log-entry.info { background: rgba(74,144,226,0.2); }
    .log-entry.loot { background: rgba(255,170,0,0.2); }
    
    .inventory {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
      margin-top: 10px;
    }
    
    .inv-slot {
      aspect-ratio: 1;
      background: rgba(74,144,226,0.2);
      border: 2px solid #4a90e2;
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      transition: all 0.2s;
    }
    
    .inv-slot:hover {
      background: rgba(74,144,226,0.4);
      transform: scale(1.1);
    }
    
    .inv-slot.empty {
      opacity: 0.3;
    }
    
    .menu-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .menu-screen.hidden {
      display: none;
    }
    
    .character-select {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      max-width: 800px;
      margin: 30px 0;
    }
    
    .char-card {
      background: rgba(74,144,226,0.2);
      border: 3px solid #4a90e2;
      border-radius: 15px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
    }
    
    .char-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(74,144,226,0.5);
      border-color: #fff;
    }
    
    .char-card.selected {
      background: rgba(74,144,226,0.4);
      border-color: #fff;
      box-shadow: 0 0 30px rgba(74,144,226,0.8);
    }
    
    .char-icon {
      font-size: 80px;
      margin-bottom: 10px;
    }
    
    .char-name {
      font-size: 24px;
      margin-bottom: 10px;
      color: #4a90e2;
    }
    
    .char-stats {
      font-size: 14px;
      color: #aaa;
      text-align: left;
    }
    
    .action-buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 15px;
    }
    
    .action-btn {
      padding: 15px;
      background: linear-gradient(135deg, #4a90e2, #7b68ee);
      border: 2px solid #fff;
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Krabby Patty', Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.3s;
    }
    
    .action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(74,144,226,0.5);
    }
    
    .action-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.9);
      border: 2px solid #4a90e2;
      border-radius: 5px;
      padding: 10px;
      z-index: 1000;
      pointer-events: none;
      font-size: 12px;
      max-width: 200px;
    }
    
    .game-over-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .game-over-screen.show {
      display: flex;
    }
    
    .game-over-title {
      font-size: 64px;
      color: #ff4444;
      margin-bottom: 20px;
      text-shadow: 0 0 30px #ff4444;
    }
    
    .final-stats {
      font-size: 24px;
      margin: 20px 0;
      text-align: center;
    }
    
    @media (max-width: 1200px) {
      .game-container {
        grid-template-columns: 250px 1fr 250px;
      }
    }
    
    @media (max-width: 900px) {
      .game-container {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
      }
      
      .header {
        grid-column: 1;
      }
      
      .sidebar {
        display: none;
      }
      
      .cell {
        width: 30px;
        height: 30px;
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
  <div class="menu-screen" id="menuScreen">
    <h1 style="font-size: 48px; margin-bottom: 20px; background: linear-gradient(135deg, #4a90e2, #7b68ee, #ff6b6b); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
      üó°Ô∏è BIKINI BOTTOM<br>DUNGEON DELVER üó°Ô∏è
    </h1>
    <p style="font-size: 20px; margin-bottom: 30px; color: #aaa;">Choose your character and descend into the depths!</p>
    <div class="character-select" id="charSelect"></div>
    <button class="btn" id="startBtn" style="margin-top: 30px; padding: 15px 40px; font-size: 20px;">START ADVENTURE</button>
  </div>
  
  <div class="game-over-screen" id="gameOverScreen">
    <div class="game-over-title">GAME OVER</div>
    <div class="final-stats" id="finalStats"></div>
    <button class="btn" id="restartBtn" style="margin-top: 20px; padding: 15px 40px; font-size: 20px;">PLAY AGAIN</button>
    <button class="btn" id="leaderboardBtn" style="margin-top: 10px; padding: 15px 40px; font-size: 20px;">LEADERBOARD</button>
  </div>
  
  <div class="game-container">
    <div class="header">
      <h1>üó°Ô∏è Dungeon Delver</h1>
      <div class="header-buttons">
        <button class="btn" id="backBtn">‚¨ÖÔ∏è MENU</button>
        <button class="btn" id="leaderboardBtn2">üèÜ LEADERBOARD</button>
      </div>
    </div>
    
    <div class="sidebar" id="playerStats">
      <h2>CHARACTER</h2>
      <div id="charInfo"></div>
      <div class="stat-item">
        <span class="stat-label">Level</span>
        <span class="stat-value" id="playerLevel">1</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Floor</span>
        <span class="stat-value" id="currentFloor">1</span>
      </div>
      <div class="stat-bar">
        <div class="stat-bar-fill hp-bar" id="hpBar" style="width: 100%"></div>
      </div>
      <div class="stat-item">
        <span class="stat-label">HP</span>
        <span class="stat-value" id="hpText">100/100</span>
      </div>
      <div class="stat-bar">
        <div class="stat-bar-fill mp-bar" id="mpBar" style="width: 100%"></div>
      </div>
      <div class="stat-item">
        <span class="stat-label">MP</span>
        <span class="stat-value" id="mpText">50/50</span>
      </div>
      <div class="stat-bar">
        <div class="stat-bar-fill xp-bar" id="xpBar" style="width: 0%"></div>
      </div>
      <div class="stat-item">
        <span class="stat-label">XP</span>
        <span class="stat-value" id="xpText">0/100</span>
      </div>
      <h2 style="margin-top: 20px;">STATS</h2>
      <div class="stat-item">
        <span class="stat-label">Attack</span>
        <span class="stat-value" id="attackStat">10</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Defense</span>
        <span class="stat-value" id="defenseStat">5</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Speed</span>
        <span class="stat-value" id="speedStat">5</span>
      </div>
      <h2 style="margin-top: 20px;">INVENTORY</h2>
      <div class="inventory" id="inventory"></div>
    </div>
    
    <div class="main-area" id="mainArea">
      <div class="dungeon-grid" id="dungeonGrid"></div>
      <div class="combat-log" id="combatLog"></div>
      <div class="action-buttons" id="actionButtons"></div>
    </div>
    
    <div class="sidebar" id="enemyStats">
      <h2>ENEMY</h2>
      <div id="enemyInfo"></div>
      <div class="stat-bar">
        <div class="stat-bar-fill hp-bar" id="enemyHpBar" style="width: 100%"></div>
      </div>
      <div class="stat-item">
        <span class="stat-label">HP</span>
        <span class="stat-value" id="enemyHpText">-/-</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Attack</span>
        <span class="stat-value" id="enemyAttack">-</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Defense</span>
        <span class="stat-value" id="enemyDefense">-</span>
      </div>
    </div>
  </div>

  <script>
    // =====================
    // GAME STATE
    // =====================
    var game = {
      player: null,
      dungeon: null,
      currentFloor: 1,
      gridSize: 20,
      selectedChar: null,
      inCombat: false,
      currentEnemy: null,
      inventory: [],
      combatLog: [],
      gameOver: false
    };
    
    // =====================
    // CHARACTER CLASSES
    // =====================
    var characters = {
      spongebob: {
        name: 'SpongeBob',
        icon: 'üßΩ',
        hp: 120,
        maxHp: 120,
        mp: 60,
        maxMp: 60,
        attack: 12,
        defense: 6,
        speed: 7,
        xp: 0,
        xpToNext: 100,
        level: 1,
        description: 'Optimistic and energetic. High HP and Speed.'
      },
      patrick: {
        name: 'Patrick',
        icon: '‚≠ê',
        hp: 150,
        maxHp: 150,
        mp: 40,
        maxMp: 40,
        attack: 15,
        defense: 8,
        speed: 3,
        xp: 0,
        xpToNext: 100,
        level: 1,
        description: 'Strong and tough. High HP and Attack, but slow.'
      },
      sandy: {
        name: 'Sandy',
        icon: 'ü§†',
        hp: 100,
        maxHp: 100,
        mp: 80,
        maxMp: 80,
        attack: 10,
        defense: 5,
        speed: 10,
        xp: 0,
        xpToNext: 100,
        level: 1,
        description: 'Fast and agile. High Speed and MP for abilities.'
      },
      squidward: {
        name: 'Squidward',
        icon: 'üé∑',
        hp: 90,
        maxHp: 90,
        mp: 100,
        maxMp: 100,
        attack: 8,
        defense: 4,
        speed: 6,
        xp: 0,
        xpToNext: 100,
        level: 1,
        description: 'Balanced mage. High MP for powerful abilities.'
      }
    };
    
    // =====================
    // ENEMY TYPES
    // =====================
    var enemyTypes = {
      jellyfish: { name: 'Jellyfish', icon: 'ü™º', hp: 30, maxHp: 30, attack: 5, defense: 2, speed: 4, xp: 15, floor: 1 },
      robot: { name: 'Plankton Bot', icon: 'ü§ñ', hp: 50, maxHp: 50, attack: 8, defense: 4, speed: 3, xp: 25, floor: 2 },
      seaHorse: { name: 'Sea Horse', icon: 'üê¥', hp: 70, maxHp: 70, attack: 10, defense: 5, speed: 6, xp: 40, floor: 3 },
      krabs: { name: 'Krab', icon: 'ü¶Ä', hp: 100, maxHp: 100, attack: 12, defense: 8, speed: 2, xp: 60, floor: 4 },
      boss: { name: 'Dungeon Boss', icon: 'üëπ', hp: 200, maxHp: 200, attack: 20, defense: 10, speed: 5, xp: 200, floor: 5 }
    };
    
    // =====================
    // ITEM TYPES
    // =====================
    var itemTypes = {
      healthPotion: { name: 'Health Potion', icon: 'üß™', type: 'consumable', effect: 'heal', value: 50 },
      manaPotion: { name: 'Mana Potion', icon: 'üíß', type: 'consumable', effect: 'mana', value: 30 },
      sword: { name: 'Rusty Sword', icon: '‚öîÔ∏è', type: 'weapon', stat: 'attack', value: 5 },
      armor: { name: 'Leather Armor', icon: 'üõ°Ô∏è', type: 'armor', stat: 'defense', value: 3 },
      krabbyPatty: { name: 'Krabby Patty', icon: 'üçî', type: 'consumable', effect: 'heal', value: 100 }
    };
    
    // =====================
    // DUNGEON GENERATION (IMPROVED)
    // =====================
    function generateDungeon(floor) {
      var size = game.gridSize;
      var grid = [];
      
      // Initialize grid
      for (var y = 0; y < size; y++) {
        grid[y] = [];
        for (var x = 0; x < size; x++) {
          grid[y][x] = { type: 'wall', visible: false, explored: false };
        }
      }
      
      // Better room generation - more rooms on higher floors
      var rooms = [];
      var numRooms = 6 + Math.floor(floor * 0.8);
      var maxAttempts = numRooms * 10;
      var attempts = 0;
      
      while (rooms.length < numRooms && attempts < maxAttempts) {
        attempts++;
        
        // Room size varies by floor
        var minRoomSize = floor > 7 ? 4 : 3;
        var maxRoomSize = floor > 7 ? 7 : 5;
        var roomW = minRoomSize + Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1));
        var roomH = minRoomSize + Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1));
        
        // Better room placement - try to place in different quadrants
        var quadrant = rooms.length % 4;
        var roomX, roomY;
        
        if (quadrant === 0) {
          roomX = 2 + Math.floor(Math.random() * (size / 2 - roomW - 2));
          roomY = 2 + Math.floor(Math.random() * (size / 2 - roomH - 2));
        } else if (quadrant === 1) {
          roomX = size / 2 + Math.floor(Math.random() * (size / 2 - roomW - 2));
          roomY = 2 + Math.floor(Math.random() * (size / 2 - roomH - 2));
        } else if (quadrant === 2) {
          roomX = 2 + Math.floor(Math.random() * (size / 2 - roomW - 2));
          roomY = size / 2 + Math.floor(Math.random() * (size / 2 - roomH - 2));
        } else {
          roomX = size / 2 + Math.floor(Math.random() * (size / 2 - roomW - 2));
          roomY = size / 2 + Math.floor(Math.random() * (size / 2 - roomH - 2));
        }
        
        // Ensure room is within bounds
        roomX = Math.max(1, Math.min(roomX, size - roomW - 2));
        roomY = Math.max(1, Math.min(roomY, size - roomH - 2));
        
        // Check overlap with margin
        var overlap = false;
        var margin = 2;
        for (var j = 0; j < rooms.length; j++) {
          var r = rooms[j];
          if (roomX < r.x + r.w + margin && roomX + roomW + margin > r.x &&
              roomY < r.y + r.h + margin && roomY + roomH + margin > r.y) {
            overlap = true;
            break;
          }
        }
        
        if (!overlap) {
          rooms.push({ x: roomX, y: roomY, w: roomW, h: roomH });
          
          // Carve room
          for (var ry = roomY; ry < roomY + roomH; ry++) {
            for (var rx = roomX; rx < roomX + roomW; rx++) {
              if (grid[ry] && grid[ry][rx]) {
                grid[ry][rx].type = 'floor';
              }
            }
          }
        }
      }
      
      // Better corridor generation - create a spanning tree
      if (rooms.length > 1) {
        // Create minimum spanning tree for corridors
        var connected = [0];
        var unconnected = [];
        for (var i = 1; i < rooms.length; i++) {
          unconnected.push(i);
        }
        
        while (unconnected.length > 0) {
          var minDist = Infinity;
          var bestConnected = -1;
          var bestUnconnected = -1;
          
          for (var c = 0; c < connected.length; c++) {
            var connIdx = connected[c];
            var connRoom = rooms[connIdx];
            var connX = Math.floor(connRoom.x + connRoom.w / 2);
            var connY = Math.floor(connRoom.y + connRoom.h / 2);
            
            for (var u = 0; u < unconnected.length; u++) {
              var unconnIdx = unconnected[u];
              var unconnRoom = rooms[unconnIdx];
              var unconnX = Math.floor(unconnRoom.x + unconnRoom.w / 2);
              var unconnY = Math.floor(unconnRoom.y + unconnRoom.h / 2);
              
              var dist = Math.abs(connX - unconnX) + Math.abs(connY - unconnY);
              if (dist < minDist) {
                minDist = dist;
                bestConnected = connIdx;
                bestUnconnected = unconnIdx;
              }
            }
          }
          
          if (bestConnected >= 0 && bestUnconnected >= 0) {
            var prev = rooms[bestConnected];
            var curr = rooms[bestUnconnected];
            
            var px = Math.floor(prev.x + prev.w / 2);
            var py = Math.floor(prev.y + prev.h / 2);
            var cx = Math.floor(curr.x + curr.w / 2);
            var cy = Math.floor(curr.y + curr.h / 2);
            
            // L-shaped corridor
            // Horizontal first
            for (var x = Math.min(px, cx); x <= Math.max(px, cx); x++) {
              if (grid[py] && grid[py][x]) {
                grid[py][x].type = 'floor';
              }
            }
            // Then vertical
            for (var y = Math.min(py, cy); y <= Math.max(py, cy); y++) {
              if (grid[y] && grid[y][cx]) {
                grid[y][cx].type = 'floor';
              }
            }
            
            connected.push(bestUnconnected);
            unconnected.splice(unconnected.indexOf(bestUnconnected), 1);
          } else {
            break;
          }
        }
        
        // Add some extra random connections for more interesting layouts
        var extraConnections = Math.floor(rooms.length * 0.3);
        for (var e = 0; e < extraConnections; e++) {
          var r1 = Math.floor(Math.random() * rooms.length);
          var r2 = Math.floor(Math.random() * rooms.length);
          if (r1 !== r2) {
            var room1 = rooms[r1];
            var room2 = rooms[r2];
            var x1 = Math.floor(room1.x + room1.w / 2);
            var y1 = Math.floor(room1.y + room1.h / 2);
            var x2 = Math.floor(room2.x + room2.w / 2);
            var y2 = Math.floor(room2.y + room2.h / 2);
            
            for (var x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
              if (grid[y1] && grid[y1][x]) {
                grid[y1][x].type = 'floor';
              }
            }
            for (var y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
              if (grid[y] && grid[y][x2]) {
                grid[y][x2].type = 'floor';
              }
            }
          }
        }
      }
      
      // Place player in first room
      if (rooms.length > 0) {
        var startRoom = rooms[0];
        game.playerX = Math.floor(startRoom.x + startRoom.w / 2);
        game.playerY = Math.floor(startRoom.y + startRoom.h / 2);
      } else {
        game.playerX = Math.floor(size / 2);
        game.playerY = Math.floor(size / 2);
      }
      
      // Place stairs in last room
      if (rooms.length > 0) {
        var endRoom = rooms[rooms.length - 1];
        var stairsX = Math.floor(endRoom.x + endRoom.w / 2);
        var stairsY = Math.floor(endRoom.y + endRoom.h / 2);
        grid[stairsY][stairsX].type = 'stairs';
        grid[stairsY][stairsX].stairs = true;
      }
      
      // Helper function to check if cell is in a tunnel (has 2 or fewer floor neighbors)
      function isTunnel(x, y) {
        var floorNeighbors = 0;
        var neighbors = [[x-1,y], [x+1,y], [x,y-1], [x,y+1]];
        for (var n = 0; n < neighbors.length; n++) {
          var nx = neighbors[n][0];
          var ny = neighbors[n][1];
          if (nx >= 0 && nx < size && ny >= 0 && ny < size && grid[ny][nx].type === 'floor') {
            floorNeighbors++;
          }
        }
        return floorNeighbors <= 2;
      }
      
      // Helper function to check if adjacent cells have enemies
      function hasAdjacentEnemy(x, y) {
        var neighbors = [[x-1,y], [x+1,y], [x,y-1], [x,y+1]];
        for (var n = 0; n < neighbors.length; n++) {
          var nx = neighbors[n][0];
          var ny = neighbors[n][1];
          if (nx >= 0 && nx < size && ny >= 0 && ny < size && grid[ny][nx].enemy) {
            return true;
          }
        }
        return false;
      }
      
      // Place enemies - difficulty scales after floor 7
      var baseEnemyCount = 3 + Math.floor(floor * 1.5);
      var difficultyMultiplier = floor > 7 ? 1 + (floor - 7) * 0.5 : 1;
      var enemyCount = Math.floor(baseEnemyCount * difficultyMultiplier);
      
      for (var i = 0; i < enemyCount; i++) {
        var placed = false;
        var attempts = 0;
        while (!placed && attempts < 100) {
          var ex = Math.floor(Math.random() * size);
          var ey = Math.floor(Math.random() * size);
          
          if (grid[ey] && grid[ey][ex] && grid[ey][ex].type === 'floor' &&
              (ex !== game.playerX || ey !== game.playerY) &&
              !grid[ey][ex].enemy && !grid[ey][ex].stairs) {
            
            // If in a tunnel, don't place if adjacent to another enemy
            if (isTunnel(ex, ey) && hasAdjacentEnemy(ex, ey)) {
              attempts++;
              continue;
            }
            
            var enemyType = getEnemyForFloor(floor);
            
            // Scale enemy stats after floor 7
            var statMultiplier = floor > 7 ? 1 + (floor - 7) * 0.3 : 1;
            
            grid[ey][ex].enemy = {
              type: enemyType.name,
              icon: enemyType.icon,
              hp: Math.floor(enemyType.hp * statMultiplier),
              maxHp: Math.floor(enemyType.maxHp * statMultiplier),
              attack: Math.floor(enemyType.attack * statMultiplier),
              defense: Math.floor(enemyType.defense * statMultiplier),
              speed: enemyType.speed,
              xp: Math.floor(enemyType.xp * statMultiplier * 1.2)
            };
            placed = true;
          }
          attempts++;
        }
      }
      
      // Place items (more items on higher floors, but less after floor 7 for difficulty)
      var itemCount = floor > 7 ? 2 + Math.floor(floor / 3) : 3 + Math.floor(floor / 2);
      for (var i = 0; i < itemCount; i++) {
        var placed = false;
        var attempts = 0;
        while (!placed && attempts < 50) {
          var ix = Math.floor(Math.random() * size);
          var iy = Math.floor(Math.random() * size);
          
          if (grid[iy] && grid[iy][ix] && grid[iy][ix].type === 'floor' &&
              !grid[iy][ix].enemy && !grid[iy][ix].item && !grid[iy][ix].stairs) {
            var itemKeys = Object.keys(itemTypes);
            // 40% chance for health potion, 20% for krabby patty, rest random
            var itemKey;
            var rand = Math.random();
            if (rand < 0.4) {
              itemKey = 'healthPotion';
            } else if (rand < 0.6) {
              itemKey = 'krabbyPatty';
            } else {
              itemKey = itemKeys[Math.floor(Math.random() * itemKeys.length)];
            }
            grid[iy][ix].item = JSON.parse(JSON.stringify(itemTypes[itemKey]));
            placed = true;
          }
          attempts++;
        }
      }
      
      return grid;
    }
    
    function getEnemyForFloor(floor) {
      // After floor 7, harder enemies appear more often
      var bossChance = floor >= 5 ? (floor > 7 ? 0.15 : 0.1) : 0;
      if (floor >= 5 && Math.random() < bossChance) {
        return enemyTypes.boss;
      }
      
      // Enemy type distribution changes after floor 7
      if (floor > 7) {
        var rand = Math.random();
        if (rand < 0.4) return enemyTypes.krabs;
        if (rand < 0.7) return enemyTypes.seaHorse;
        if (rand < 0.9) return enemyTypes.robot;
        return enemyTypes.jellyfish; // Rare weak enemy
      }
      
      // Normal progression
      if (floor >= 4) return enemyTypes.krabs;
      if (floor >= 3) return enemyTypes.seaHorse;
      if (floor >= 2) return enemyTypes.robot;
      return enemyTypes.jellyfish;
    }
    
    // =====================
    // RENDERING
    // =====================
    function renderDungeon() {
      var grid = game.dungeon;
      var gridEl = document.getElementById('dungeonGrid');
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = 'repeat(' + game.gridSize + ', 1fr)';
      
      // Update visibility
      updateVisibility();
      
      for (var y = 0; y < game.gridSize; y++) {
        for (var x = 0; x < game.gridSize; x++) {
          var cell = grid[y][x];
          var cellEl = document.createElement('div');
          cellEl.className = 'cell';
          
          if (cell.visible || cell.explored) {
            cell.explored = true;
            
          if (x === game.playerX && y === game.playerY && game.player) {
            cellEl.className += ' player';
            cellEl.textContent = game.player.icon;
            } else if (cell.enemy && cell.visible) {
              cellEl.className += ' enemy';
              cellEl.textContent = cell.enemy.icon;
            } else if (cell.item && cell.visible) {
              cellEl.className += ' item';
              cellEl.textContent = cell.item.icon;
            } else if (cell.stairs && cell.visible) {
              cellEl.className += ' stairs';
              cellEl.textContent = '‚¨áÔ∏è';
            } else if (cell.type === 'floor') {
              cellEl.className += ' floor';
            } else {
              cellEl.className += ' wall';
            }
            
            if (!cell.visible) {
              cellEl.className += ' hidden';
            }
          } else {
            cellEl.className += ' wall hidden';
          }
          
          if (cell.visible || cell.explored) {
            // Fix closure issue - capture x and y properly
            (function(cellX, cellY) {
              cellEl.addEventListener('click', function() {
                movePlayer(cellX, cellY);
              });
            })(x, y);
          }
          
          gridEl.appendChild(cellEl);
        }
      }
    }
    
    function updateVisibility() {
      var range = 5;
      for (var y = 0; y < game.gridSize; y++) {
        for (var x = 0; x < game.gridSize; x++) {
          var dist = Math.abs(x - game.playerX) + Math.abs(y - game.playerY);
          game.dungeon[y][x].visible = dist <= range;
        }
      }
    }
    
    function updateUI() {
      if (!game.player) return; // Safety check
      
      var p = game.player;
      
      document.getElementById('charInfo').innerHTML = '<div style="font-size: 48px; text-align: center; margin-bottom: 10px;">' + p.icon + '</div><div style="text-align: center; font-size: 18px; color: #4a90e2;">' + p.name + '</div>';
      document.getElementById('playerLevel').textContent = p.level;
      document.getElementById('currentFloor').textContent = game.currentFloor;
      
      var hpPercent = (p.hp / p.maxHp) * 100;
      document.getElementById('hpBar').style.width = hpPercent + '%';
      document.getElementById('hpText').textContent = p.hp + '/' + p.maxHp;
      
      var mpPercent = (p.mp / p.maxMp) * 100;
      document.getElementById('mpBar').style.width = mpPercent + '%';
      document.getElementById('mpText').textContent = p.mp + '/' + p.maxMp;
      
      var xpPercent = (p.xp / p.xpToNext) * 100;
      document.getElementById('xpBar').style.width = xpPercent + '%';
      document.getElementById('xpText').textContent = p.xp + '/' + p.xpToNext;
      
      document.getElementById('attackStat').textContent = p.attack;
      document.getElementById('defenseStat').textContent = p.defense;
      document.getElementById('speedStat').textContent = p.speed;
      
      renderInventory();
      
      if (game.currentEnemy) {
        var e = game.currentEnemy;
        document.getElementById('enemyInfo').innerHTML = '<div style="font-size: 48px; text-align: center; margin-bottom: 10px;">' + e.icon + '</div><div style="text-align: center; font-size: 18px; color: #ff4444;">' + e.type + '</div>';
        var enemyHpPercent = (e.hp / e.maxHp) * 100;
        document.getElementById('enemyHpBar').style.width = enemyHpPercent + '%';
        document.getElementById('enemyHpText').textContent = e.hp + '/' + e.maxHp;
        document.getElementById('enemyAttack').textContent = e.attack;
        document.getElementById('enemyDefense').textContent = e.defense;
      } else {
        document.getElementById('enemyInfo').innerHTML = '';
        document.getElementById('enemyHpBar').style.width = '0%';
        document.getElementById('enemyHpText').textContent = '-/-';
        document.getElementById('enemyAttack').textContent = '-';
        document.getElementById('enemyDefense').textContent = '-';
      }
    }
    
    function renderInventory() {
      var invEl = document.getElementById('inventory');
      invEl.innerHTML = '';
      
      for (var i = 0; i < 16; i++) {
        var slot = document.createElement('div');
        slot.className = 'inv-slot';
        
        if (game.inventory[i]) {
          slot.textContent = game.inventory[i].icon;
          slot.title = game.inventory[i].name;
          slot.addEventListener('click', function(idx) {
            return function() {
              useItem(idx);
            };
          }(i));
        } else {
          slot.className += ' empty';
        }
        
        invEl.appendChild(slot);
      }
    }
    
    function addLog(message, type) {
      game.combatLog.push({ message: message, type: type || 'info' });
      if (game.combatLog.length > 50) {
        game.combatLog.shift();
      }
      
      var logEl = document.getElementById('combatLog');
      logEl.innerHTML = '';
      for (var i = game.combatLog.length - 1; i >= 0; i--) {
        var entry = document.createElement('div');
        entry.className = 'log-entry ' + game.combatLog[i].type;
        entry.textContent = game.combatLog[i].message;
        logEl.appendChild(entry);
      }
    }
    
    // =====================
    // GAME MECHANICS
    // =====================
    function movePlayer(tx, ty) {
      if (game.inCombat || game.gameOver) return;
      
      var dx = tx - game.playerX;
      var dy = ty - game.playerY;
      var dist = Math.abs(dx) + Math.abs(dy);
      
      if (dist !== 1) return; // Only move one cell
      
      var targetCell = game.dungeon[ty][tx];
      if (!targetCell || targetCell.type === 'wall') return;
      
      // Check for enemy
      if (targetCell.enemy) {
        startCombat(targetCell.enemy, tx, ty);
        return;
      }
      
      // Check for item
      if (targetCell.item) {
        pickUpItem(tx, ty);
      }
      
      // Check for stairs
      if (targetCell.stairs) {
        nextFloor();
        return;
      }
      
      // Move player
      game.playerX = tx;
      game.playerY = ty;
      
      renderDungeon();
      updateUI();
    }
    
    function pickUpItem(x, y) {
      var item = game.dungeon[y][x].item;
      if (!item) return;
      
      if (game.inventory.length < 16) {
        game.inventory.push(item);
        game.dungeon[y][x].item = null;
        addLog('Picked up ' + item.name + '!', 'loot');
        
        // Visual effect
        createParticle(x * 40 + 20, y * 40 + 20, item.icon);
        
        if (typeof soundManager !== 'undefined' && soundManager.play) {
          soundManager.play('money');
        }
      } else {
        addLog('Inventory full!', 'info');
      }
    }
    
    function useItem(index) {
      if (!game.inventory[index]) return;
      
      var item = game.inventory[index];
      
      if (item.type === 'consumable') {
        if (item.effect === 'heal') {
          var heal = Math.min(item.value, game.player.maxHp - game.player.hp);
          game.player.hp += heal;
          addLog('Used ' + item.name + '! Restored ' + heal + ' HP.', 'heal');
        } else if (item.effect === 'mana') {
          var mana = Math.min(item.value, game.player.maxMp - game.player.mp);
          game.player.mp += mana;
          addLog('Used ' + item.name + '! Restored ' + mana + ' MP.', 'heal');
        }
        
        game.inventory.splice(index, 1);
        updateUI();
        
        if (typeof soundManager !== 'undefined' && soundManager.play) {
          soundManager.play('cash');
        }
      } else if (item.type === 'weapon' || item.type === 'armor') {
        // Equip item (simplified - just add stats)
        game.player[item.stat] += item.value;
        game.inventory.splice(index, 1);
        addLog('Equipped ' + item.name + '!', 'info');
        updateUI();
      }
    }
    
    function startCombat(enemy, x, y) {
      game.inCombat = true;
      game.currentEnemy = JSON.parse(JSON.stringify(enemy));
      game.currentEnemy.x = x;
      game.currentEnemy.y = y;
      
      addLog('Combat started! ' + enemy.type + ' appears!', 'info');
      
      // Combat visual effect
      for (var i = 0; i < 10; i++) {
        setTimeout(function() {
          createParticle(x * 40 + 20, y * 40 + 20, '‚öîÔ∏è');
        }, i * 50);
      }
      
      updateUI();
      renderActionButtons();
      
      if (typeof soundManager !== 'undefined' && soundManager.play) {
        soundManager.play('scream');
      }
    }
    
    function endCombat() {
      if (game.currentEnemy) {
        var x = game.currentEnemy.x;
        var y = game.currentEnemy.y;
        game.dungeon[y][x].enemy = null;
      }
      
      game.inCombat = false;
      game.currentEnemy = null;
      updateUI();
      renderActionButtons();
      renderDungeon();
    }
    
    function playerAttack() {
      if (!game.inCombat || !game.currentEnemy) return;
      
      var damage = Math.max(1, game.player.attack - game.currentEnemy.defense + Math.floor(Math.random() * 5));
      game.currentEnemy.hp -= damage;
      addLog(game.player.name + ' attacks for ' + damage + ' damage!', 'damage');
      
      // Visual effect
      if (game.currentEnemy.x !== undefined && game.currentEnemy.y !== undefined) {
        createParticle(game.currentEnemy.x * 40 + 20, game.currentEnemy.y * 40 + 20, '‚öîÔ∏è');
      }
      
      if (game.currentEnemy.hp <= 0) {
        var xp = game.currentEnemy.xp;
        game.player.xp += xp;
        addLog('Enemy defeated! Gained ' + xp + ' XP!', 'info');
        
        // Victory particles
        if (game.currentEnemy.x !== undefined && game.currentEnemy.y !== undefined) {
          for (var i = 0; i < 5; i++) {
            setTimeout(function() {
              createParticle(game.currentEnemy.x * 40 + 20, game.currentEnemy.y * 40 + 20, '‚≠ê');
            }, i * 100);
          }
        }
        
        // Check level up
        while (game.player.xp >= game.player.xpToNext) {
          levelUp();
        }
        
        endCombat();
        updateUI();
        
        if (typeof soundManager !== 'undefined' && soundManager.play) {
          soundManager.play('victory');
        }
      } else {
        enemyAttack();
      }
      
      updateUI();
    }
    
    function enemyAttack() {
      if (!game.currentEnemy) return;
      
      var damage = Math.max(1, game.currentEnemy.attack - game.player.defense + Math.floor(Math.random() * 3));
      game.player.hp -= damage;
      addLog(game.currentEnemy.type + ' attacks for ' + damage + ' damage!', 'damage');
      
      if (game.player.hp <= 0) {
        gameOver();
      }
      
      updateUI();
    }
    
    function levelUp() {
      game.player.xp -= game.player.xpToNext;
      game.player.level++;
      game.player.xpToNext = Math.floor(game.player.xpToNext * 1.5);
      
      game.player.maxHp += 20;
      game.player.hp = game.player.maxHp;
      game.player.maxMp += 10;
      game.player.mp = game.player.maxMp;
      game.player.attack += 3;
      game.player.defense += 2;
      game.player.speed += 1;
      
      addLog('LEVEL UP! You are now level ' + game.player.level + '!', 'heal');
      
      if (typeof soundManager !== 'undefined' && soundManager.play) {
        soundManager.play('ohyeah');
      }
    }
    
    function nextFloor() {
      game.currentFloor++;
      
      // Difficulty warning after floor 7
      if (game.currentFloor === 8) {
        addLog('‚ö†Ô∏è DANGER: The dungeon grows more treacherous!', 'damage');
        addLog('Enemies are stronger and more numerous!', 'damage');
      } else if (game.currentFloor > 7) {
        addLog('Descending to floor ' + game.currentFloor + '... (EXTREME DIFFICULTY)', 'damage');
      } else {
        addLog('Descending to floor ' + game.currentFloor + '...', 'info');
      }
      
      // Floor transition effect
      for (var i = 0; i < 20; i++) {
        setTimeout(function() {
          createParticle(game.playerX * 40 + 20, game.playerY * 40 + 20, '‚ú®');
        }, i * 50);
      }
      
      game.dungeon = generateDungeon(game.currentFloor);
      renderDungeon();
      updateUI();
      renderActionButtons();
      
      if (typeof soundManager !== 'undefined' && soundManager.play) {
        soundManager.play('ready');
      }
    }
    
    function gameOver() {
      game.gameOver = true;
      game.inCombat = false;
      
      var score = game.currentFloor * 1000 + game.player.level * 100 + game.player.xp;
      
      document.getElementById('finalStats').innerHTML = 
        '<div>Reached Floor: ' + game.currentFloor + '</div>' +
        '<div>Level Reached: ' + game.player.level + '</div>' +
        '<div>Final Score: ' + score.toLocaleString() + '</div>';
      
      document.getElementById('gameOverScreen').classList.add('show');
      
      setTimeout(function() {
        if (typeof showLeaderboardModal === 'function') {
          showLeaderboardModal('dungeon-delver', 'Bikini Bottom Dungeon Delver', score);
        }
      }, 1000);
      
      if (typeof soundManager !== 'undefined' && soundManager.play) {
        soundManager.play('scream');
      }
    }
    
    function renderActionButtons() {
      var btnEl = document.getElementById('actionButtons');
      btnEl.innerHTML = '';
      
      if (game.inCombat) {
        var attackBtn = document.createElement('button');
        attackBtn.className = 'action-btn';
        attackBtn.textContent = '‚öîÔ∏è ATTACK';
        attackBtn.onclick = playerAttack;
        btnEl.appendChild(attackBtn);
        
        var runBtn = document.createElement('button');
        runBtn.className = 'action-btn';
        runBtn.textContent = 'üèÉ RUN';
        runBtn.onclick = function() {
          if (Math.random() < 0.5) {
            addLog('Successfully ran away!', 'info');
            endCombat();
          } else {
            addLog('Failed to run away!', 'damage');
            enemyAttack();
          }
        };
        btnEl.appendChild(runBtn);
      } else {
        var waitBtn = document.createElement('button');
        waitBtn.className = 'action-btn';
        waitBtn.textContent = '‚è∏Ô∏è WAIT';
        waitBtn.onclick = function() {
          addLog('You wait...', 'info');
        };
        btnEl.appendChild(waitBtn);
        
        // Heal button (uses MP)
        var healBtn = document.createElement('button');
        healBtn.className = 'action-btn';
        healBtn.textContent = 'üíö HEAL (10 MP)';
        healBtn.onclick = function() {
          if (game.player.mp >= 10 && game.player.hp < game.player.maxHp) {
            var healAmount = Math.min(30 + game.player.level * 5, game.player.maxHp - game.player.hp);
            game.player.hp += healAmount;
            game.player.mp -= 10;
            addLog('You heal for ' + healAmount + ' HP!', 'heal');
            createParticle(game.playerX * 40 + 20, game.playerY * 40 + 20, 'üíö');
            updateUI();
            
            if (typeof soundManager !== 'undefined' && soundManager.play) {
              soundManager.play('gary');
            }
          } else if (game.player.mp < 10) {
            addLog('Not enough MP!', 'info');
          } else {
            addLog('Already at full health!', 'info');
          }
        };
        if (game.player.mp < 10 || game.player.hp >= game.player.maxHp) {
          healBtn.disabled = true;
        }
        btnEl.appendChild(healBtn);
      }
    }
    
    function createParticle(x, y, emoji) {
      var particle = document.createElement('div');
      particle.className = 'particle';
      particle.textContent = emoji;
      var gridEl = document.getElementById('dungeonGrid');
      var rect = gridEl.getBoundingClientRect();
      particle.style.left = (rect.left + x - window.scrollX) + 'px';
      particle.style.top = (rect.top + y - window.scrollY) + 'px';
      document.body.appendChild(particle);
      setTimeout(function() {
        if (particle.parentNode) {
          particle.remove();
        }
      }, 1000);
    }
    
    // =====================
    // INITIALIZATION
    // =====================
    function initCharacterSelect() {
      var selectEl = document.getElementById('charSelect');
      selectEl.innerHTML = '';
      
      for (var key in characters) {
        var char = characters[key];
        var card = document.createElement('div');
        card.className = 'char-card';
        card.innerHTML = 
          '<div class="char-icon">' + char.icon + '</div>' +
          '<div class="char-name">' + char.name + '</div>' +
          '<div class="char-stats">' +
          'HP: ' + char.maxHp + ' | MP: ' + char.maxMp + '<br>' +
          'ATK: ' + char.attack + ' | DEF: ' + char.defense + ' | SPD: ' + char.speed + '<br>' +
          '<small>' + char.description + '</small>' +
          '</div>';
        
        // Fix closure issue - capture key in IIFE
        (function(charKey, charCard) {
          charCard.addEventListener('click', function() {
            document.querySelectorAll('.char-card').forEach(function(c) {
              c.classList.remove('selected');
            });
            charCard.classList.add('selected');
            game.selectedChar = charKey;
            console.log('Selected character:', charKey);
          });
        })(key, card);
        
        selectEl.appendChild(card);
      }
    }
    
    function startGame() {
      if (!game.selectedChar) {
        alert('Please select a character!');
        return;
      }
      
      console.log('Starting game with character:', game.selectedChar);
      game.player = JSON.parse(JSON.stringify(characters[game.selectedChar]));
      console.log('Player initialized:', game.player.name, game.player.icon);
      
      // Reset game state
      game.currentFloor = 1;
      game.dungeon = generateDungeon(game.currentFloor);
      game.inventory = [];
      game.combatLog = [];
      game.gameOver = false;
      game.inCombat = false;
      game.currentEnemy = null;
      
      document.getElementById('menuScreen').classList.add('hidden');
      
      addLog('Welcome to the dungeon, ' + game.player.name + '!', 'info');
      renderDungeon();
      updateUI();
      renderActionButtons();
    }
    
    function restartGame() {
      document.getElementById('gameOverScreen').classList.remove('show');
      document.getElementById('menuScreen').classList.remove('hidden');
      game.selectedChar = null;
      game.player = null;
      game.dungeon = null;
      game.inCombat = false;
      game.currentEnemy = null;
      game.gameOver = false;
      document.querySelectorAll('.char-card').forEach(function(c) {
        c.classList.remove('selected');
      });
    }
    
    // =====================
    // KEYBOARD CONTROLS
    // =====================
    document.addEventListener('keydown', function(e) {
      if (game.gameOver || game.inCombat) return;
      
      var nx = game.playerX;
      var ny = game.playerY;
      
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
        ny--;
      } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
        ny++;
      } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        nx--;
      } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        nx++;
      } else {
        return;
      }
      
      if (nx >= 0 && nx < game.gridSize && ny >= 0 && ny < game.gridSize) {
        movePlayer(nx, ny);
      }
    });
    
    // =====================
    // EVENT LISTENERS
    // =====================
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', restartGame);
    document.getElementById('leaderboardBtn').addEventListener('click', function() {
      if (typeof showLeaderboardModal === 'function') {
        var score = game.currentFloor * 1000 + (game.player ? game.player.level * 100 : 0);
        showLeaderboardModal('dungeon-delver', 'Bikini Bottom Dungeon Delver', score);
      }
    });
    document.getElementById('leaderboardBtn2').addEventListener('click', function() {
      if (typeof showLeaderboardModal === 'function') {
        var score = game.currentFloor * 1000 + (game.player ? game.player.level * 100 : 0);
        showLeaderboardModal('dungeon-delver', 'Bikini Bottom Dungeon Delver', score);
      }
    });
    document.getElementById('backBtn').addEventListener('click', function() {
      if (confirm('Return to menu? Progress will be lost.')) {
        document.getElementById('menuScreen').classList.remove('hidden');
        restartGame();
      }
    });
    
    // Initialize
    initCharacterSelect();
  </script>
</body>
</html>

